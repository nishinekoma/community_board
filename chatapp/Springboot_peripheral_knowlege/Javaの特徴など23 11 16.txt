学校Java
    ・マシン語　    　
        １６進数で書かれたCPUの集まり
    ・アセンブリ言語　 assembly(アセンブリ)集会、集合、議会、組み立て
        低水準プログラミング言語
        16進数の命令をアルファベット３文字の簡略記憶記号
        直接解釈できる機械語に1対1で対応したプログラミング言語のことを言う。
    ・コンパイル言語 complied(コンパイル)蓄積する。
        souce codeの一度に全て機械語に翻訳
        そうするために全て翻訳して実行しなければエラーがわからない
    ・インタプリタ言語（LISP）interpreter 通訳者　解釈者　JVM　JavaVM
        souce codeからマシン語も数行づつ機械語に翻訳しながらやる。
        一行ずつ翻訳して実行するためにエラーが発見しやすい（）

    souse codeから機械が学習可能な言語に翻訳してから
    • (メリット) 事前にマシン語に翻訳をするため、実行速度が速い（オーバーヘッドが少ない）
    • (メリット) エラーを事前に発見しやすい
    • (デメリット) コンパイルに時間がかかる
    • (デメリット) 動作環境毎にコンパイルし直す必要がある
    JVM(Java Virtual Machine) 
                                Javaのプログラムを動かすために必要なソフトフェア
                                中間クラス.classで
                            　　Javaのプログラム⇒Javaコンパイラ（バイナリコード）⇒JVM⇒対象のOSに変換
                            　　JVMがあるからこそ環境に依存せずにできる。
                                https://style.potepan.com/articles/35672.html

    オペランドは　コンピュータの演算における値や変数のこと
    オペレータ　演算子；足し算や掛け算などの計算や値の大小を比較する際に使われる記号
    インクリメント　今の数字に1を足すこと
    リテラル　ソースコードの中に直接書きこんである文字とか数字とか

    Javaのint型は32bit
    doubleは     64bit
    ・コンパイラ言語

            ーーーJavaーーーー
            ・1995年の言語である。
            ・コンパイル・インタプリタ方式（コンパイラとインタプリタのいいとこどりをしている（ハイブリッド方式）
                    souce code　⇒　（一機にコンパイル）
                    中間コード.class　⇒　インタプリタ　＋　JITコンパイラ    JITコンパイラは「PCに搭載されているCPUが直接実行できる言語（マシン語）」
                    マシン語　⇒　実行
                メリット
                ・事前のエラーチェック
                ・コンパイルによる中間コードの最適化
                ・インタプリタにより実行環境に依存しない。
                ・実行時コンパイル（JIT）により実行速度も早い
            ・way
                ・サーバーサイドで多く利用
                ・本格的なオブジェクト指向
                ・様々なOS動作する
            ・特徴
                ・マルチプラットホーム  ・マルチスレッド
                ・ネットワーク機能      ・エラー処理
                ・汎用描画機能          ・Java以外の外部ライブラリ（JNI）
                ・ガーベジコレクション（ゴミ回収）メモリ領域のうち不要になったものを自動的に解放し
            ・プログラミングエラーの種類
                ・構文エラー
                    ・souce code上のルール違反　コンパイラかインタプリタで見つける
                ・コンパイルエラー
                    ・コンパイル時に発見されたエラー
                ・ビルドエラー
                    ・複数のソースコードをコンパイル・リンクする作業
                    ・エラーメッセのヒントで矛盾の解決
                ・実行時エラー
                    ・プログラム実行中に発生・たまに異常終了
                    ・不正なメモリへのアクセスによる参照エラー（てらしあわせ）
                    ・メモリが足りなくなるスタックオーバーフロー
                    ・ゼロで割ってしまった演算エラー
                    ・サーバで１か月に一回だけしか発生しないなど
                ・論理エラー
                    ・プログラムが動作し期待道りに動作しない
                    ・アルゴリズムエラー
        
        Javaのプログラムについて
            キャスト
                double d = 123.0;
                int a = int(d);
            Javaの標準入力
                import java.io.IOException; //入出力例外IOExceptionクラス
                import java.io.BufferedReader; //入力用BufferedReaderクラス
                import java.io.InputStreamReader; //入力用InputStreamReader
                ※上記3行をまとめて以下のように書くこともできる
                import java.io.*; //入出力パッケージをまるごとインポート
                標準入力で起きる可能性のある例外のための宣言
                    public static void main(String[] args) throws IOException {
                標準入力の入力を扱うBufferedReaderクラスを初期化・main()の中で宣言
                    BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));
                    buf は変数名なので、好きな変数名を付けて良い
                標準入力から文字列を読む
                String s; //文字列を代入するための文字列型変数宣言
                    s = buf.readLine(); //標準入力からの文字列をsに代入 
                標準入力から数値を読む
                    buf.readLine()で文字列を標準入力　(キーボード)から読み込みんで↓
                    Integer.parseInt()で整数に変換
                    int a; //整数型変数を宣言
                    a = Integer.parseInt(buf.readLine()); //標準入力から整数を代入
                基本制御構造
                1.順次実行
                2.分岐実行
                3.繰り返し実行
                • while文 条件が満たされ限り繰り返す
                • do-while文 条件が満たされる限り1回以上繰り返す　一回は必ず通る。　一回通して一回は処理をさせる。そこにif文書けば何かは表示される。
                • for文 決まった回数繰り返す

                インクリメント　i++
                デクリメント　i--
                    インクリメントとデクリメントについて　後置演算と前置演算がある　https://www.javadrive.jp/start/ope/index6.html
                    後置演算　              　前置演算
                    y = x++                  y = ++x
                    =                        =
                    y = x;                   y = x + 1;
                    y = x + 1                y = x

    while文は条件を満たしているかを判断するタイミングが処理の実行前となるため、
    条件を満たさずに1度も実行されないことがありますが、do while文は条件を満たしているか
    どうかを処理の実行後に判断するため、最低でも1度は処理が実行されるという違いがあります。


    ・自然言語（日本語、英語など）
        複雑・曖昧でも解釈される
    ・プログラミング言語（人口言語）
        シンプルかつ厳密である。
    ・構造化プログラミング
        ３つの基本制御構造（逐次、分岐、反復）関数・ブロックを用いて
        　構造をわかりやすくする。
        オブジェクト指向設計。
        ・サブクラスはスーパークラスと置き換え可能でなければいけない。



            ーーLinuxーー
            ・way
            UNIX（Linux）はネットワークサーバで広く利用
            世界で最も普及　AndroidもLinux
            ・コマンド
            　　ls (list 作業ディレクトリのファイル一覧を表示
                cd (change directory 作業ディレクトリの変更
                cp (copy  ファイルのコピー
                mv (move ファイルの移動・名前の変更
                rm (remove ファイルの削除

    プログラム例
    import java.io.IOException;
    import java.io.BufferedReader;
    import java.io.InputStreamReader;
    public class Kadai2_1 {
    public static void main(String[] args) throws IOException {
    BufferedReader buf = new BufferedReader(new InputStreamReader(System.in));
    String s;
    s = buf.readLine();
    System.out.println("入力データは " + s + " です。");
    }
    }

    for文のテスト
    for(;式;) while(式) do-while(式)の式は論理値(boolean)を返す1。
    //第3章まで終わった

    //Javaの英単語や単語当

    JVM(Java Virtual Machine) Javaのプログラムを動かすために必要なソフトフェア
                            　　Javaのプログラム⇒Javaコンパイラ（バイナリコード）⇒JVM⇒対象のOSに変換
                            　　JVMがあるからこそ環境に依存せずにできる。

    第七回
    制御命令の構文
    • if文
        • if(式)文
        • if(式)文else文
    • while文
        • while(式)文
    • for文
        • for(式; 式; 式)文
    continue文
        • continue文はループの途中からループの戻る https://www.javadrive.jp/start/for/index10.html
        • for文、while文(do-while文)で利用できる
        ・最も内側の１つのループをスキップする。
        ・多重ループのネストの外側までスキップする場合には、ラベル付きcontinue文を使います。
        
    ネストとは、あるものの中に、それと同じ形や種類の（一回り小さい）ものが入っている状態や構造のこと。ITの分野では、コンピュータプログラムやデータ構造において、
    ある構造の内部に同じ構造が含まれている状態のことを指す。

    break文
    • switch文ですでに利用している
    • break文は制御構造から抜け出す命令
        for
        for
        break文
        }
        ここに移る

        ・ラベル付きbreak文
        ラベル名
        　for
            for
                if{
                    break　ラベル名；
                }
                    ラベルの付いたFor分全体から抜ける
    • for文、while文(do-while文)、switch文
    　で利用
    ・制御構造から抜ける。
        制御構造とはなにか
        ・Forとかwhile文の制御構造とか


    Javaのデータ型
        Javaのデータ型は、大きく分けて
        1. 基本データ型
            • boolean, byte, char, short, int, long(めっちゃおおきな整数値を入れられる), float, double
                暗黙型変換→
                byte → short and char → int → long → float → double 
                                                                ←←←キャストによる型変換  
        2. 参照型：場所を参照しているから参照型　intは整数だが、Stringは参照する。　https://www.f.waseda.jp/moriya/im6/14.reference.html
            •参照型の変数にはデータの（参照型）格納場所が記録される。  
            • クラス型, 配列型
            • Stringクラスは文字列を扱うためのクラス型(参照型)
            • Stringクラスの特殊な例として文字列リテラルがある
            • Stringクラスの特殊な演算子として+(文字列演算子)がある
            • クラス型は生成にnew演算子を用いる
            • クラス型は基本データ型と違い、機能(メソッド)がある
            • 例) String.equals(), String.length(), String.charAt()
        3. null型
            • null(法律上)無効の、価値のない、ゼロの、零の
                new演算子
                    • クラス型の生成には、new演算子を用いる
                    • すでに BufferedReaderクラスの生成でnew演算子を利用している
                    •　new演算子は、生成したオブジェクトを返す
                    String s = new String("Hello, World!");
                    String s = "Hello, World！";　　　　　　　この行-1と同じことを意味する。    
                    https://www.bold.ne.jp/engineer-club/java-char
        4.参照型の比較
            • 参照型は、データが直接格納されるのではなく、データへの参
                照先（格納場所）が記録されている
            • 二つの参照型変数を==で比較した場合、参照先（格納場所）
                が同じかどうかを比較する

        参照型の比較
            String s1 = new String("Hello, World!");
            String s2 = new String("Hello, World!");
            if(s1 == s2) {
            System.out.println("s1 == s2");
            }else{
            System.out.println("s1 != s2");
        }   
            結果
            s1 != s2//格納されている場所が違うため


        メソッドについて
        　String.equals()メソッド　｛String型はイコールかメソッド｝
        •equals()は文字の並びが一致する場合 true を返す
        String s1 = new String("Hello, World!");
        String s2 = new String("Hello, World!");
        if( s1.equals(s2) ) {
            System.out.println("s1 equals s2");
        }else{
            System.out.println("s1 not equals s2");
        }
        結果　s1 equals s2

        配列型変数の比較
        • 参照型の変数はデータの参照先アドレスを格納する
        • 配列型変数を==で比較すると、同じアドレスかどうかを調べる
            int[] a = {10,20};
            int[] b = {10,20};
            System.out.println(a==b);
            実行結果　false

        • 配列の値が同じか比較する場合は、要素の値を比較する
            int[] a = {10,20};
            int[] b = {10,20};
            System.out.println(a[0]==b[0]);
            System.out.println(a[1]==b[1]);
            実行結果　true
                    　
------------------学　校　て　す　と　範　囲　外---------------------------------------------
定数フィールド　final


配列
    配列は値の集合を扱うための　インスタンス　配列クラスから作られたもの
        要素　：　配列が扱う値のこと
    配列型変数へ代入 配列インスタンスの生成
    int[] array = new int[0]
    配列型変数はあくまで参照する値を代入するだけ
        int f[][] = [要素数][配列の数]
    もし配列の要素数指定に　｛｝　初期化子を使うと要素数は自動的に計算される
        ので要素の指定はしない
        かつ、初期化子は変数宣言と同時にしか使えない
        ；をつかって変数宣言と配列のインスタンス生成のタイミングを分けることはできない

staticを考える前提知識
静的メンバ（static｛静的｝）　クラスに属する共有の情報や機能を実現するために存在する　下記の行のため、クラス名.メソッド名で指定が可能
        ・存在意義：クラスの特定の情報を保持するため・共通の機能を提供するため
インスタンス変数　インスタンス化された時の個々のフィールドや格納された値のことを指す

static について
    
    JVMがクラスファイルを読み込んだ後、「ロード」と呼ばれるが、ロード後、クラスファイルは
    staticな部分とそれ以外に分離される。
    それぞれの異なる空間に配置される。
    ロード後、static領域とそれ以外のヒープ領域に分類される。
    mainメソッド(public staitc void main(String args[])){}ないで呼び出す時に、
    インスタンス化せずにクラス名.メソッド名で済んでいるのは同じstatic領域に住んでいる殻である。

    ヒープ領域とスタック領域について
    ヒープ領域　heap(ヒープ)積み重ねたもの、体積　どっさり
    動的に確保と解放を繰り返せるメモリ領域　データの仮置き場や、臨時の作業台のような存在
    インスタンス化したものに別の値を格納するときに動的に開放する必要がある。
    詳細
        プログラムの実行時には、OSからソフトウェアに対して一定量のヒープ領域が与えられます。
        ソフトウェアは、必要に応じて任意にヒープ領域を確保・解放できます。
    スタック領域
        スタック領域は確保したのとは逆の順番で開放するのが特徴
        最後に確保した順に開放する
        「入れ子構造」がスタック領域との相性がいい
    Q_なぜstatic領域とヒープ領域に分ける必要があるのか
    A_static領域は元の状態（インスタンス変数に依存しない）であり
      ヒープ領域は動的に変わるインスタンス変数を開放したり一時的に保持するためにあるのですね。


pointer 「ポインタ」　オブジェクトが存在している場所(メモリ上のアドレス)を指し示すところ
                    　アドレスは具体的なもの(絶対番地)であるが　抽象的に「ポインタ」という
                    「オブジェクトのある場所を指すもの」



ラッピングする　    プログラミングの文やで、あるクラスや関数、データ型などが提供する
                    機能やデータを含み、別の形で提供すること。
                    ※そのようにして用意されたクラスや関数などのことを「ラッパー」という
                        元の機能を包んで覆い隠す役割を持つ。
                    使いどころ
                    ・古くからある資産を、新しい環境で行かせること。

列挙　一つ一つ数え立てて並びたてること
enum(イーナム 列挙型)　複数の定数を一つのクラスとしてまとめておくことができる型
    特徴
    ・enumで定義する定数を列挙子と呼びます。
    ・クラスとして定義されるのでフィールドやメソッドも定義できる点が大きな特徴
    ・swith文で扱いやすい
    ・クラスのように扱えるがインスタンス化はできない
        ・enumのインスタンス化はenum内部で行う１回きり
    ・上の行のためenumの各インスタンスはプログラムの中で一つということが保証される。
        enumは定数として利用可能
        基本書式と命名規則
        命名規則
            ・一般的にすべて大文字
            ・enumを宣言するクラス命名規則は一般的に「enum列挙型名.java」となります。
        public enum 列挙型名｛
            列挙定数１,
            列挙定数２,
            (中略)
            列挙定数Ｎ,
        ｝;
          実例
                public enum Days {
            MONDAY,
            TUESDAY,
            WEDNESDAY,
            THURSDAY,
            FRIDAY,
            SATURDAY,
            SUNDAY
        }


        public class EnumExample {
            public static void main(String[] args) {
                // 曜日を表示する例
                Days today = Days.MONDAY;//このように指定しているが全てインスタンス化されている。

                switch (today) {
                    case MONDAY:
                        System.out.println("今日は月曜日です。");
                        break;
                    case TUESDAY:
                        System.out.println("今日は火曜日です。");
                        break;
                    // 他の曜日も同様に続ける
                    default:
                        System.out.println("今日は何曜日かわかりません。");
                }
            }
        }


constractor　インスタンスを作ったタイミングで実行されるメソッドのこと
            ・コンストラクタの特徴
            　コンストラクト　クラスからインスタンスで生成する時に自動で実行される
                            インスタンス化のところのコンストラクタも見とく。
            
                            　文例：インスタンス生成と同時にコンストラクタによって
                                    HPに10代入される。
                constract(コンストラクト)　構築する
            ・コンストラクタの使い型
            public class ABc {
                public ABc() {}//classと同じ宣言名はコンストラクタとみられる。   
            }
            コンストラクタと初期化子
            すべてのコンストラクタで一部だけ共通の処理をする必要があった場合、
            すべてのコンストラクタにその処理を書くのは煩雑なので初期化子を使ってやる
                初期化子はすべてのコンストラクタで共通する前処理を記述するために使用します。
                そのため初期化子はコンストラクタが実行される前に実行される
                例code
                    public class Sample {
                        {
                            //初期化子で行う共通の前処理 最初に表示される。
                            System.out.println("B")
                        }
                    }
            ・コンストラクタの注意点
                １・もし、オーバーロードした別のコンストラクタを呼び出す時にはそのコードは
                　　最初に記述しなければならない｛thisを使って別のコンストラクタを呼び出す前に何らかの処理をしてはならない｝
                １の例
                    public class Sample{
                        public Sample{
                            this(B);//　１　別のオーバーロード下コンストラクタを呼び出すために最初に記述する
                            System.out.println("A");
                        }
                        public Sample(String str){//@Overload ※オーバーロードのやり方に注意

                        }
                    }
Qなぜオーバーロードした別のコンストラクタ呼び出す時にはそのコードは最初
    に記述しなければならないのか
    簡単に言うと不具合が生じる場合がある。
        public Person(String name){//不具合の例
            Private Strinng
            public Person(String name){
                this.age = 0;//this(B,12);がここにあれば、もしコンストラクタで指定された場合に初期化せずに済む
                this(name, age)            　//上記の続き⇒初期化しなければこの行this(name,age)のコードのageの部分がNullpointException（null・代入されていない状態）になってしまう。
            }
            public Person(String name,int age)
        }
初期化子
    static int a;
    static｛
        a = 19;
    ｝
    class Sample
            ..main
                System.out.println(Sample.a);//19が表示される。

インスタンス化
・インスタンス化（オブジェクト化）に際しコンストラクタが一つもないクラスは許されない。
                                                だが、特例としてクラスに一もコンストラクタがない場合は自動的についかされる。
                                                継承関係？superクラス　javaSilver紫p250 をみてやる
                                                抽象クラスはインスタンス化できない　インターフェイスとか
                                                ファイルjavaSilverのtest.java p279をみて深く理解する
                                                ・コンストラクタは継承されない
                                                    だがサブクラスに処理を書いていないとスーパークラスのコンストラクタが呼ばれる。
                                                ・暗黙的コンストラクタ
                                                    クラス内には必ず１つはコンストラクタがなければならないので
                                                    ない場合はpublic クラス名()が追加される
                                                ・コンストラクタのルール
                                                    ・メソッド名とクラス名を同じにすること
                                                    ・戻り値型は記述できない。｛記述するとメソッドとして見られる。｝　×　void クラス名とかは　×
                                                    ・newと一緒にしか使えない
                                                    ・どんなアクセス修飾子でも大丈夫　これはルールではないが上記３っつのルールに
                                                    　従っていれば大丈夫
    継承関係によるインスタンス化
    Javaのextendsは、クラスの継承を宣言するために使用されます。継承を行うクラスを「サブクラス」と呼び、継承されるクラスを「スーパークラス」と呼びます。
    ・継承関係による代入（上記をのぞく）はできる　インターフェイスの変数にサブクラスの型を代入する
                                                　継承関係なしでもキャストしてやる　※コンパイルは成功するがインスタンス化されたものの中だけにある場合は例外が発生する。ClassCastException
    ・staticメンバにポリフォリムズは適用されないため、インスタンス化されたクラスとメソッドがかぶっていても
    　呼び出されるのは変数宣言したほうのメソッドが呼び出される。JavaSilver紫p292 6-16参照
    ・配列自体は親の型でも、インスタンスメソッドをオーバーライドしている場合、はサブクラスが優先して呼び出される。
    ・非staticメソッド（インスタンスメソッド）からstaticメソッドへ直接アクセスすることは可能

継承関係
・サブクラスはスーパークラスの次の２点は引き継ぐことはできない
    ・コンストラクタ
    ・privateなフィールドやメソッド
    /*インスタンス化と継承関係　classA と　classB extends classAである*/
・継承関係にある２つのクラスで同名のフィールドが使われているとき
    ・フィールドを参照した場合は、　変数の型　で宣言された法を使う。
    ・メソッドを呼び出した場合には、※メソッド内の指示    に従う。
    注意※　どの変数を使うかはコンパイル時に決まる。
・継承関係にある２つのクラスで同名のメソッドが定義されている時。
    ・オーバーライドしているほうextendsのほうが呼び出される。
    ・メソッドを呼び出した場合には、※メソッド内の指示    に従う。
    注意※　どのメソッドを使うかは実行時によって判断される。
            継承関係によるポリフォーリズムを使ったときは　「どのインスタンスが動いているか」
            「どのメソッドがオーバーライドしているか」

/---*instanceof*---/https://www.bold.ne.jp/engineer-club/java-instanceof
    使い時
    ・型がインターフェイスの場合、その実装クラスが何かを調べるときに使う。
    ・クラスが実装しているインターフェイスを知る。
    ・継承関係にあるか試すとか・・？


/---*ポリフォーリズムを使ったインスタンス化*---/
次の２点に注意する
    ・継承関係や実装関係があり、ポリフォーリズムが成り立つ条件が備えているか
    ・インスタンスを扱っている「型」（そのものの扱い方）にメソッドが定義してあるか。
考え
    ・インスタンス化の際に変数で宣言されたほうにそのメソッドやフィールドがなければ、そのものがコンパイルエラー
    ・継承の関係がある　か　実現の関係がある。
インスタンス（それかオブジェクト）　メモリ領域。　クラスという金型から仮想世界で活動する実体
                            例インスタンス化したものを4人せいせいする。
    instance (インスタンス)　例、実例、事例、事実、段階
                            ・抽象クラスやインターフェースからインスタンスを生み出すことはできません。
継承 依然作ったクラスと似通ったクラスを作るときに便利なもの
    public class A(継承先)　extends B(継承元)　｛｝　//Aのコ―ドは基本的にはBと同じ
    
    全ての共通するクラスを作りたくなる　その時に不都合が生じる
        ・不都合A　将来未設定で値が決められない
                    心配
                    ・オーバーライドのし忘れ　・メソッドが「何もしないのが正しいのか」・「何をする予定なのか」区別できない
                    ・意図せずnewされる。（つまり将来未設定クラスがあるのがインスタンス化されること）  
        ・Java以外の外部ライブラリ（JNI）                                  

    /---*アップキャスト・ダウンキャストFOR継承関係*---/
アップキャスト　サブクラス型をスーバークラス型に変換すること
ダウンキャスト　元の型に戻すこと　差分として定義したメソッドを使える。
        キャストはコンパイラに対する　「互換性の保証」　とみなされる。
        キャストは変数の扱い型を変えるだけで参照先にあるインスタンスの種類を変更できるわけではない。

p424 抽象クラス
abstract(アブストラクト)抽象化クラス        詳細未設定のメソッド　p424
　public abstract class Character {
    public abstract void attack(Matago m);
    }
    //attack()というメソッドは宣言すべきであるが、具体的にどう動くか、内容がどうなるかまでは
    　現時点では確定できないので、メソッド内部の処理はここでは記載しない。
    　｛｝ではなく　；　をつける。
    ・抽象クラスの特徴
        ・フィールドを定義できる。
        ・抽象クラスはnewによるインスタンス化が禁止される。※継承前提のクラスとして扱う。
        ・オーバーライドの強制(抽象メソッドのみ　具象メソッドは継承される。)
            ・サブクラスが抽象クラスでも、＠overrideして実装しなければならない　例:public abstract void methodB();
        ・具象メソッドと抽象メソッドの両方を持つことができる。
    ・抽象クラスをつ来るときに意識すべきこと
        ・共通点を見つける。
        ・
    ・具象クラス｛具象：物が実際にそなえている形｝　処理内容を書いたメソッド（具象メソッド）のまとまったクラス
    ・具象メソッド:上記のとおり
    ・抽象メソッド｛抽象：ひとくくりにした概念｝    処理内容を記述していないメソッド　abstractメソッド 

p435 インターフェイス
    何のためにあるか
        ・ポリフォーリズムのためにある。個人開発では実感しずらいが複数人の場合だと実感しやすい。
        ・https://camp.trainocate.co.jp/magazine/java-interface-abstract/#:~:text=interface%EF%BC%88%E3%82%A4%E3%83%B3%E3%82%BF%E3%83%BC%E3%83%95%E3%82%A7%E3%82%A4%E3%82%B9%EF%BC%89%E3%81%AF%E3%80%81%E3%82%AF%E3%83%A9%E3%82%B9,%E3%81%A0%E3%81%91%E3%82%92%E5%AE%9A%E7%BE%A9%E3%81%97%E3%81%BE%E3%81%99%E3%80%82
        ・
        　効果
        ・インターフェイスはクラス方型だけを取り出したもの　型はそのものの扱い方を決めるための情報
            変数を宣言するときに型を指定するのは、その変数の扱い方を決めるため。
        ・同じインターフェイスをimplements(実装)する子クラス達に共通のメソッド群を実装できるように強制できる。
        ・あるクラスがインターフェイスを実装していれば、少なくともそのインターフェイスが定めたメソッドは持っていることが保証される。
        　正しく継承が用意られて継承ツリーを上へたどると次のような現象が起きる。
        ・抽象メソッドが増える。一応存在するメソッド
        ・抽象メソッドやフィールドが減っていく　（クラスに定義してある抽象メソッドやフィールドが減っていく。）
    使用条件
        ・コンパイラによって自動的にpublicが付与される。他のアクセス修飾子は定義不可
        ・基本全てのメソッドは抽象メソッドである。例外あり      便利　省略できる。
        ・基本的にフィールドを一つ持たない。ただしフィールドを作るときは２つのルールがある
        ・インターフェイスでのオーバーライドにjava.lang.Objectはオーバーライドできない。
            ・finalを使って動的に値が変更されない　定数であること
            ・staticを使って、インスタンスが生成できなくても使えること。

            /*---default句---*/
        ・Java８　default句を使うととでinterface内にメソッドを実装できる
            ・defaultメソッドは実現クラスが持つべきデフォルトの実装を持つ。変更はオーバーライド
            ・java.lang.Objectクラスはオーバーライド不可（例:toStringメソッドとか）
            例１    default public void dhello(){System.out.println("Hellow")}
            例２    default public String dhello(String str){System.out.println(str)}
            ・defaultメソッドでオーバーライドしたメソッドから元のメソッドを呼び出したいときは
            　次の構文を使う　p 252 JavaSilver黒本
                使用どころ : インターフェイスを複数個実装したときに各インターフェイスに
                            同じメソッドがある（かつsignatuer同じ時）に特定するときに使う。
                構文　：　インターフェイス名.super.メソッド名
                注意※　・上の構文は　「２つ以上の実現や継承の階層をまたいで行うことはできない。」
                        ・直接実現したクラスでないと実行不可能 
            
        ・staticはメソッドを定義可能｛｝
            初期化子は必ず書かなければいけない　｛｝←初期化子
        　      interface ...{//staticで書いているので定義可能。
                default String greeting() { return "A"}
                static void c(){}
                static void c(int c){}
                public static void c(){}
                
    使用方法
        ・implements(実装する)　インタ―フェイス名１、インターフェイス名２，・・・ 
        ・オーバーライドして使う（@override）の時のみ
        ・interfaceでvoid c();を実装する場合、JVMが暗黙の了解でpublic アクセス修飾子をつけるので
        　実装時にオーバーライドする場合はpublic void c();
        ・
        例code
         public interface Creature {
            void run();                 //puclic abstractを書かなくてもよい
            //定数宣言
            double PI = 3.141592;       //自動的にpublic static finalが補われる。
         }
    使い方
    インターフェイスを継承して子クラスを定義する場合は　
            例１    public class クラス名　implements インターフェイス名 {}
            例２    public class クラス名　implements 親インターフェイス１,親インターフェイス２・・
        インターフェイス名のインターフェイスを実装してクラス名を作る。
    インターフェイスの拡張
    public interface Human extends Creature{ //Humanインターフェイスを拡張する。元はCreature
    }

ローカル変数
    メソッド内で宣言した変数のこと
        特徴
        ・そのフィールド内だけで有効な存在である。

引数（argument）{アーギュメント}
    メソッドを呼び出す際に、呼び出し元から値を渡すことができる。この時
    い渡される値のことを引数と呼ぶ。

オーバーロードについて(多重定義)
・同じメソッドを定義すること。
    シグネチャ（メソッド名｛引数｝）が異なっている物、
        引数の数、型、順番が異なっている必要がある。
　特徴
    ・仮引数が異なれば同じ名前のメソッドを定義してもよい。
    ・JVMは見分けることができる。（仮引数と実引数が一致した場合のみ）

オーバーライドについて（再定義）
    オーバーライドはサブクラスでスーパークラスに定義されたメソッドを再定義すること。
        ・メソッドの再定義のため、シグネチャsignature（メソッド名、引数リストの数、数、順番）は
        　同じ必要がある。
        ・戻り値型は同じ型か、サブクラス型であること。
        ・アクセス修飾子は同じかより緩いもの指定する。
        ・

/*---共変戻り値---*/
Java5から導入　同じ型かそのサブクラスであれば、オーバーライドしたメソッドの戻り値型に
            　指定できる用になった。
/*---アクセス修飾子について---*/　パッケージ関連にもつながる
参考文献　https://java-code.jp/134　アクセス修飾子
UMLの可視性　UMLでアクセス修飾子に記号で表す
アクセスの定義　接続できるかどうか
修飾子　　　　　クラスやインターフェイスやそのメンバーの性質を決めるキーワードで
                それぞれの先頭に付与する
public      すべてのクラスからアクセスできる　　　UML　＋
protected   現在のクラスかサブクラスか同じパッケージからアクセスできる　UML＃
なし        現在のクラスと同じパッケージのクラスからアクセスできる。他のパッケージからはアクセス不可。
                                                UML　～
private     現在のクラスからだけアクセス可能　他のクラスはメソッドを通して利用可能　UML　-

p430
    implements(インプリメンツ)実装する。

多様性polymorphism(ポリモーフィズム)
    ・staticメンバには適用されない
    ・「あるものを、ざっくりとらえる。」
    ・私たちが現実世界で楽するためにざっくりと捉えることをプログラムで実現する機能こそ　多様性である。
    ・/*p465*/多様性をかつようするためには「箱の型」と「中身の型」という異なる形が関係してくる。
    ・/*p474*/で気づいたこと：　箱の表面はちがえど,本質的にnew Slimeなのは変わりがない。
        「箱の型」・「中身の型」について                //Chapter12参照
            ・「箱の型」　　どのメソッドを呼べるかを決定する
            ・「中身の型」　メソッドが呼ばれたらどう動くのかを決定する。
             //箱(メソッド)　変数名 ＝ 中身（動き）
                 Slime s = new Slime();
                 Monster m = new Slime();
                 s.run(); m.run();

カプセル化について
    なぜ重要なのか詳細
        AとBというクラスがあってＢのメソッドがＡのフィールドに直接アクセスできる設計は
        関係するデータやメソッドが一つにまとまっていない状態にあるといえる。BのメソッドがAの
        フィールドを使うのであればそのメソッドはAにあるべきだから。
/*詳細欄終わり*/
        カプセル化はオブジェクト指向設計の最も基本的な原則の一つです。
            使用用途
            ・クラスの目的を明確化するために行う。
            ・他のクラスに重複するデータや処理がない状態を目指すというもの
            重要
            ・関係するフィールドとメソッドが一つにまとまっていること。
                なぜ重要なのか詳細を見る（上の行に書いてある）
    ・オブジェクトに対しての別のプロジェクトや外部からのアクセスをできなくさせる
    　ために行います。
    以下の条件を満たす
    ・フィールド変数を「private」 にする。
    ・「public」 のメソッドを用意する。

/---*データの隠ぺい*---/
上のカプセル化された物も、システムが１０年や２０年たち法律や更新によって変わって
複雑化してしまうかもしれない。それを　アクセス修飾子により不用意な利用を禁じること
をデータの隠ぺいと呼ぶ





他の英単語
協調発音　
overload(オゥヴァロォゥドゥ)(...に)荷を積みすぎる、(...に)(...を)積みすぎる、負担をかける。
Asset（アセット）資産
IntangibleAsset（インタンジブルアセット）無形資産
TangibleAsset(タンジブルアセット)      　有形資産
Patent（パテント）特許権
array(アレイ)整列させる。
Cast(キャスト)投げる、投じる、位置ずけ、配役する。
Class(クラス)同様なもののひとまとまり、学級、等級
Exception(エクセプション)例外
accessor(アクセサ)外部からアクセスするもの
void(ボイド)がまったくなくて、欠ける、からの、空の、空虚な、無効の
null(ヌル、ナラ)(法律上)無効の、価値のない、ゼロの、零の
equals(イクォールㇲ)数量・程度などが等しい
length(レングス)長さ、縦、丈、長さreferenc
Index(インデックス)索引、表示、指標、指数。人差し指という意味がつよい　 his index finger　  aの右肩に掛け算を繰り返す回数のことを指数というをいう。
bind(バインド)縛る、結びつける、巻きつける、包帯する、くるむ
Empty(エンプティ)中身がからの、無意味な、当てのない
parameters(パラメータ)変数のこと 外から入ってくる値　処理結果に影響を与える外部から投入される変動要素
util(ユーティル)ユーティリティのこと
utilitie(ユーティリティ)　utilityの複数形
utility(ユーテュエリィ)有益、有用、実利
currnent(カレント)現時点の、現在の、流通している
Calendar(カレンダー)暦、日程表、年次目録
JST Japan　Standard Time 　日本標準時間
Standard(スタンダード)名詞・可算名詞:　標準、基準...................................................
parse(パース)動詞:　解剖する、　品詞・文法的関係を説明する。
pattern(パターン)型、様式、原型、模型
Zoned(ぞー)(外観的・特徴で区別する)地域、区域、地帯
Duration(デュレーション)持続・存続
Period(ピュリエード)時代・時期　（発達過程の）段階、期、現代
reference(リファレンス)名刺・形容詞(...に)言及（すること）、論及、参考、※コア：参考文献　ドキュメントを見る
Instans(インスタント)瞬間
Milli(ミリ)...の１０００分の１の意
Date(データ)日付、期、年代、時代、（物事の）始まりと終わりの年
Time(タイム)（過去・現在・未来と続く）時、時間、時の経過、歳月、
Range(レェインヂュ)(変動する)幅、範囲、限界　コア　ある範囲内に（並んだもの)
Equal(イークオ)等しい、平等、対等の、均等な、互角の、(...と)平等の、(...に)耐えられて
Document(ドキュメント)名詞　文書、書類、記録、文献、証書、
PlatForm（プラットフォーム）IT業界の主な意味：「土台や基盤となる環境」全てのプラットフォームには「➀サービスの提供者」と「➁利用者」をつなぐための
                                            場を提供するという役割・特徴がある。
detail(ディテェール) ※名詞　：詳細、細部、細目、細かい面、ささいなこと
      75%がこの発音  ※動詞　：「～について詳細に述べる」　「～を詳述（詳しく述べること。）する」
Effect(エフェクト)｛原因から直接引き起こされる｝結果、(結果を引き起こす)効力
temporal(テンポーラル)形容詞　　現世の、世間的な、※コア：時を表す、時制の、こめかみの
plus(プラス)プラスの、余分の、好ましい、...の上（じよう）,...歳以上の、ほかに何かを加えた
matter(マター)問題、事、事柄、(原因となる)事柄、(...の)種、　　コト※事柄、質量を伴う物;
append(`アピーエンド)動詞(...に)添える、付加する
concat(コンカット)IT用語　文字列を結合する　conncatenate
concatenate(コンカティネイト)(...を)鎖状につなぐ　くさりのようにつながっている状態
with(ウィズ)｛コア的イメージ｝：付随するものと一緒に存在する。　
Regular(レギュラー)いつもの、普通の、習慣的な、定期的な
expression(エクスプレッション)表現する、顔の表情、顔つき。
be applicable(ビーアプリケーブル)適用できる 
applicable(ビーアプリケーブル)形容詞：適用できる、当てはまる、（...に）適用できて、適切で
signature(シグネチャ)著名、(調子・拍子)記号、
defined(ディファインド)動詞　定義された
regex(regular expression)正規表現の略
wrapper(ワッパー)包む人、包むもの
Integer(インテジャー)整数、完全体　整数型変数
contains(コンテインズ)含む、包含する( Ａの内部にＢをふくんでいるという状態のことです。)
contain(コ（ケ）ンテイン)　包含(Aの内部にBを含む、Bが成り立てばAも成り立つという関係)　(...を)(内に)含む、　物理的に含む
include(インクルード)抽象的、概念的に含む　※※(全体の一部として)含む、
generic(ジェネリック)一般的な、総称的な、包括的な（全体をまとめている様を意味する言葉。 類似した言葉として「総括的」）
iterate(イテレータ)～を繰り返し言う、反復する　語源 it (go)は、exit (出口) = ex (out ; 外へ) + it (go ; 行く)、から連想できます
insert(インサ`ァルト)(...に)差し込む、挿入する、聞き入れる、差しはさむ、（...を）掲載する
Hash(ハ`ッシュ)寄せ集め、ごたまぜ
pref(プレフ)prefectureの略
prefecture(プレ`:フェクチャー)県、府、知事管舎、長官の食
synatax(シンタックス)統語論｛文やその要素となる構造についての研究
Runtime(Runtime)実行
throw(スロー)投げる、ほうる、なげつける、投げ与える、投げかける、浴びせる
statement(ステートメント){名詞}述べること、声明、供述、
Spring(スプリング)コア　突然に出てくるもの
offset(オフセット)(…を)差引勘定する、相殺(そうさい)する、(…で)(…を)相殺する、(…を)(…で)相殺する、
frame(フレーム)(建造物の)骨組み、(車両の)車枠　
Compornent(コンポーネント；名詞)構成している、成分の
organization(オルガニゼーション)組織、機構、団体、編成、協会
lacale(ロケーレ)現場、場所、場面、背景
accept(アクセプト)受け入れる、受納する、引き入れる、認める
compare(コンペア―)(類似・相違を示し相対的価値を知るために)比較する、(…と)比較する、
negative(ネガティブ)　負の数
positive(ポジティブ)　正の数
argument(アーギュメント)名詞「引数」、「議論、主張、論拠」
employee(エンプロエィ)従業員、被雇用者｛雇われて仕事して賃金をもらう側のこと｝
Serializable（シリアライズ・直列化）オブジェクトを出力ストリームに書き出すことをシリアライズまたは直列化と呼びます。
Operation(オペレーション)操作、運転、作業
mismatch(ミスマッチ)動詞　組み合わせを謝る、不釣り合いな縁組をさせる
predicate(プレディケイト)述語、[動詞predicating　or predicated　＋ 目的語を]基づかせる　
                        述語｛文法上、主語を表すものの動作・作用・性質などを述べた語｝
re^move(リムーブ) 取り去る、取り除く、脱ぐ、はずす、(…へ)移す、移動させる、解任する、
Consumer(カンサ―マー)消費者
Supplier(サプライヤー)供給者
Unary(ユーナリィ)単項、単一　単一の要素または成分からなる、あるいは、単一の要素または成分（前t内の構成にあずかる要素的なもの）にかかわる
summary(サマリー)「概要」や「要約」、「ほんで、まとめるとどーゆーことよ？」のこと。「合計」のこと
LectureHall(レクチュアーホール）講堂、大教室
Auditorium(アウデゥトォウリウォン)聴衆席、観客席、公会堂
parent(ペアレント)親、子供がいる人、原因となるもの、元
Throwable(スローエーブル)投入可能な
Arithmetic（アリスマティック）算数、算術、算数の能力、計算
Arith(アリス)算術、算数、算数に関する　　Arithmeti（cal・c）の省略
export(エクスポート)書き出し　あるソフトウェアで作成・編集したデータを他のソフトが詠み込める形式に変換したり
                            　そのような形式でファイルに保存することを指す。 訳され方　公開する 出力する
import(インポート)他のソフトウェアで作成されたデータを自らが利用できる形に変換して読み込むことを指す
require(リクエイア)必要とする、（権利として、権力によって）（...を）要求する (...を)命ずる
                　命令する、命じる
describe(ディスクライブ)(...を)言葉で述べる、記述する、描写する、(...を)(言葉で)説明する
                        (...を)(...と)評する、みなす、言う、描く、書いて運行する。
                        コア※　上から下へ順番に書く事。
resolution(レゾリューション)解決、分析、回答、決意、決心、不屈
root 起動モジュール？
current(カレント)※現在流れている
                今の、現在の、現在通用している、現行の、流通している、流行しているコア
Archive(アーカイブ)記録保管場所、文書局、公文書、古文書
entry（エントリー）入る、入力、見出し、入口、侵入
initialization(イニシャライゼーション)初期化
occur(オカ―)（...に）起こる、生じる、発生する、浮かぶ　
occurred(オカード)occerの過去形　発生した
during(デュアリング)｛前置詞｝（特定の期間の）...の間ずっと、...の間中　の間に　
boot(ブート)｛IT用語で説明｝PCを起動するとOSが操作可能な状態になるまで自動的に行われる処理
automatically(オウトメティカリィ)　自動的に　機械的に
generate(ジェネレート)引き起こす　※自動や手順通りに何かを生み出す英語表現
cause(カーズ)※　引き起こす　（結果を生み出す）原因、理由、根拠electro swing
replace(リプレイス)（...に）取って代わる、（...の）後任になる、（...を）交換する
constant(コンスタント)不変の、一定の
constants(コンスタンツ)定数
heap(ヒープ)積み重ねたもの、体積　どっさり
swing(スウィング)振動、旋回、振幅、旋回　変動、回動｛正逆方向に円運動すること｝
                ｜｜　動詞　振る　揺れ動く
console(コンソール)本体、卓
assign(アサイン)割り当て、地位の任命、業務の割り当て、
individual(インディビジュアル)個々の、各個の、ー個人の、個人的な、特有の
re-arranging(リーアレンジング)rearrangeの現在分詞（...を）再び整備する、再配置、再び配列する　再編成する
arrange(アレンジ)動詞｝整える、配列する、配置する、順序立てる、準備する
execute(エグゼキュート)実行する
executing(エグゼキューティング)｛現在分詞の場合｝実行中　
Stopping　妨げている
Improve（インプルーブ）(..を)改良する、改善する、進歩させる、価値を高める。
refactoring(リファクタリング)プログラムの外部的ふるまいを変えることなく、内部構造
                            としてのソースコードを変更すること。
perform(パフォーム)実行する、果たす　収める、機能する、働く
strategy(ストラテジ)戦略、方法、計画、方針、方策
client（クライエント）クライアント　客　依頼主
Runnable（ランタイム）実行可能な
Descriptor（ディスクリプタ）記述子、指定子
Predicate(プレディケイト)名詞　術部　述語　｜動詞　断言する　断定する
digit(ディジット)名詞　桁、数字、数値
Implement(インプリメント)ハードウェアやソフトウェアに新しい機能や仕様、部品などを
                        組み込むこと。実装という意味の英単語。
Adjuster(アジァスター)調整器、調整装置
Array（アーレイ）配列、並べ
general(ジェネラル)形容詞　一般的、汎用、　｜名詞　全般的、概要、将軍
Definition(ディフィニィション)定義、解像度、画質、当然、精細度、限定、明細化、鮮明度。
Conparable（コンパレ―ブォル）相当する、匹敵する、同程度、同等。
prefix(プレフィックス)接頭辞、先頭、前置、接頭語
Otherwise(アザーワイズ)副詞｜そうでない場合、さもなければ、または、限り、あるいは、さもないと
                        　　それ以外の場合は
order(オーダー)※コア　順序付けられた秩序
lexicographically(レキシコグラフィカリィ)辞書式順序で、　辞書への掲載順
    lexicon(レキシコン)辞書　｛特にギリシャ語・ラテン語・ヘブライ語などの古典語の｝
                    　語彙
    graphically(グラフィカリィ)視覚的に、生々しく、写実的｛事実をありのままに映し出そうとする傾向のあるさま｝に
syntax(シンタックス）名詞｜構文論、文法、記述、構文論
literal(リテラル)名詞｜文字、定数、文語　　形容詞｜逐語的な｛翻訳・解釈などで、文の一語一語を忠実にたどること。逐字。「―的に訳す」｝
edition(エディション)版
Resizable(リザイザブル)サイズ変更可能な、サイズを変更でき
optional(オプショナル)名詞｜任意、必須、付属、別売り、付加
permits(パァミッツ)許可、許し、許容　動詞｜許す//多分ｓついてるから名詞
including(インクルーティング)前置詞
binary(バイナリ)バイナリ、２進数、２値、２項、２成分の
variable(ヴァリエィボウ)可変、変化　＝変数｛という意味になる｝
Reference type variable　参照型変数
sequence(シークエンス)並んだ順番にデータや手順を取り扱う処理方式などのことを意味する場合が多い。
legal(リーガル)正規、本来、合法、
illegal(イリィーガル)違法な、非合法な、不当な
compose(コンポ―ス)構成する、作る、作曲する。
perspective（パースペクティブ)視野、観点、視点。　IDE上での意味は特定のタスクすに焦点を当てたUIレイアウト。
view(ビュー)表示の仕方
existence(イグジステンス)存在、実在、現存、
exis(イグジス)存在（？
Calculator(カルキュレイター)電卓
subtract(サブトラクト)(...を)減じる、引く
declaration(デクラレイション)　宣言、告白、発表
declare(デクレラァ)(...を)宣言する、布告する、(...を)(...と)公表する
specifies(スペシフィケイション)　具体的に述べる。明確に指定する、詳細を決める。
specif(スペーシィ)明確という意味がある。　ニュアンス的に
specify(スペシフィ)※指定する、明確に述べる、特定する　特定する
specification(スペシフィケイション)仕様書　設計書　明細
specific(スペシフィック)固有の<To> , <..に>特有の
valid(バリッド)　有効な　確かな　効力がある
indicate(インディケイト) ※直接的に示す 簡単に述べる　動詞：指し示す、指摘する、示す、
conformance(コンフォーマンス)　規格適合性　適合
conform(一致する) 一致する　従う　ニュアンス：合わせる
recognition(レコグニション)認識　（理解近いニュアンス）
intent（インテント）名詞　※狙い　目標、意図　
commitment(コミットメント)　形容詞　責任　約束 確約
particular(プロテキュラー)　(同種の他のものと区別する意味合いで容易られる)特に
par(パー) 名詞 同等、基準、
construct(コンストラクト)建築する　作成する　構築する
retrieve(リトリーヴ)取得する　取り戻す　検索する
retrieved by(リトリビード)によって取得される
present(プレゼント)形容詞:現在の、出席している、※存在している 動詞:授与する、提示する 名詞:贈り物 授与する
presence(プレゼンス)※配置、存在、あること、現存
declaration(デクレイション)宣言、決議、明言
consider(コンサンサイダー)　考える、検討する、考慮する、考察する
annotated(アノテーティッド)　注釈（追加の情報（詳細）をつけるという感じ）をつける。
Conversely(コンバースリィ)　逆に、反対に、逆に言えば、逆関係において
Concretely(ココンクリートゥリィ）kɑnkríːtli 　副　具体的に
without(ウィショウト)コア　...なしで　...なしに、　...がなければ　...することなく、
context(コンテクスト)　名詞　状況、環境（文章の）前後関係　文脈　脈絡
denote(デュノート) 示す 表示する
provide(プラヴァィドゥ)　もたらす　供給する、（...供給する）,与える、(...を供給する)
syntactic(シンタックティック)構文規則の、構文の規則に関する、構文の規則に従う
classification(クラスフィケイション)名詞：分類、区分　
    分類された各区分がclass
appear(アピア―)　出現する、現れる、世に出る
split(スプリット)分かれる、引き裂く、断ち割る、分かれ目
retention(リテンション)名詞（不可算名詞）保持、保有、維持、保持力、記憶力
Attribute(アトリビュート)属性
circumstance(シルクムスタンス)名詞　ある事件・人・行動などに関連する周囲の)事情、状況、(人の置かれた)環境、境遇、出来事
Variant(ベェリエント)名詞: 形容詞:異なる、相違した　 基準または標準と異なるさま 異なるバージョンとか
acting(アクティング)代理の
authorizer(オーソライザー)承認者
authorize(オウソライズ)権威を与える、正式に許可する、許可する　ニュアンス　https://nuancebook.com/words/88/
features()特徴　ニュアンス機能
    function：
    イメージ＝「do／〜する、作動する」
    ニュアンス＝「中立」
    →作用・働き＝製品の特性を表すには不適切
    feature：
    イメージ＝「have／持っているもの」
    ニュアンス＝「ポジティブ」
    →「訴求したい魅力的な機能・特徴」を表すことができる
ording(オーダリング)名詞:順序付け　秩序化　形容詞:命令の、注文の、発注の、
explanation(エクスプレネーション)説明、エキスポ、解釈、弁明、弁解
various(ベェリアウス)形容詞　様々な、いろいろ、
accumulates(アキュウミレィトス)蓄積する、貯める
Unmodifiable(アンモディファェボウ)　変更不可能な
modifiable(モディフェイボウ)　変更可能な
disallows(ディサロウズ)ニュアンス：～を不許可にする。
/-tango 単語　ここまで-/
英語文法
前置詞の後ろには目的語

現在分詞について
    ・「（まさに）～している状態」を表す単語で、「動作」と「状態」をあわせもっています。
    beingとか　..されつつある　...であるので,...されること


to + 動詞の原形　~するために

他動詞　https://www.rarejob.com/englishlab/column/20200806/
    「“他”のもの（目的語）を必要とする動詞」。必ず目的語がつきます。
        ※目的語がついて「～を」と言うときは他動詞
        ・They go to Shinjuku.　 ＝go+前置詞+名詞
自動詞
「  自分だけで意味が成り立つ動詞」。目的語は必要ありません。
        ・I like watching movies.　＝like＋目的語watching　//have、give、likeなども他動詞です
        ・I like to watch movies.　＝like＋目的語to watc
英語熟語
英語例文おすすめサイト
https://context.reverso.net/%E7%BF%BB%E8%A8%B3/%E8%8B%B1%E8%AA%9E-%E6%97%A5%E6%9C%AC%E8%AA%9E/then+enter

less than (A) (A)以下である
for order ｛～を｝順序付ける、整理する
can get 　を手に入れることができる　得られる
then enter その時入力する　移行する
to be　をする、　を　すべき　「～になる」「～される」　なところ　
get around　回避する
a little bit 少し
pass to 渡す　変化する
come into existence（イグジステンス）存在するようになった
container（コンテナ)容器、入れ物
the Following is ... 以下が
other than 選択肢を限定し特定の条件や要素を除外し他の物を指すフレーズ。
            ～以外とか
nor 接 ~もまたない　否定　
In more detail フレーズであり、前述文の詳細を述べる　より詳細には、さらに詳細に　もっと詳しく
by default 通常は　標準的に
    byの使用は、　「条件」　「状態」をさし示すためによく使われる
in which 　先行詞を修飾する　先行詞＋in which + 主語 動詞
    基本的使用
        主語＋動詞＋目的語の後に「in which」　主語＋動詞
may be ことによると　たぶん　もしかしたら
may appear　現れる可能性がある。
under some circumstance　ある状況下では
as a + B ~Bとして

　副詞
単語一つ一つの意味
as 
 原因と結果が「イコール」：〜なので
 As it is Sunday today , I have no work to do. 今日は日曜日なので仕事がない。
 時間的に「イコール」：〜する時
 As I entered the hotel, I saw him ホテルに入った時＝彼を見た時

to　を使う時
to ~~目的文

文脈上でのthenの使い方
    文脈の途中に来るとき
        ※「それから・次に」のように物事の「順序」
        ・　全文から次に動作する言葉とか　
        ・　then what? で、次は？とか
    
    文脈の最後に来るthen
        ※過去または未来のある一時点を指す
        ・その時私はみたいな時に使う
        ・その時会いましょうとか
    
文
    主語→　文の成分の一つ　「何が」　を示す文節を言います


/----*助動詞 in the on 冠詞について*----/
空間を表す前置詞「in」
    ・次に、「in」は、空間的な広がりの中にある（いる）イメージです。

冠詞の 「the」
    ・文章や会話の中にすでに一度登場している名詞
    ・常識的に世界に1つしかないものを表す名詞
    ・海洋、海峡、河川、運河、山脈、砂漠などの一部の固有名詞

/----*発音*----/
参考：https://nativecamp.net/blog/20190626_pronounce
母音
    ・  a [æ]
        顎を一気に下げながら「エ～ア」と音が変化するように発音
        　例　Apple(ェアプッル)
        発音記号	発音方法
            [æ]	「ア」の口で「エ」と発音
            [ʌ]	軽く口を横に開いて、短く「ア」と発音
            [ə]	軽く口を開き力を抜いて弱く「ア」と発音
            [əː]	[ə]と同じ口の形で、舌を動かさず「アー」と伸ばして発音
        
    ・　o [a/ɔ]　
        「ア（オ）～」と音が変化するように顎を下げながら発音
                ※　日本語の「ア」で発音しないように注意
        　例　double (ドァ(オ)ブル)
    ・　o を /ʌ/　（オ　より　あ　に近い） と発音する場合
            /ʌ/ は口を自然に開けた状態にし、舌の位置を中央付近に
            置いて発音されます。「ア」は「ア」でも、口を大きく開けて
            発音するアの音（ /ɑ/ ）ではなく、口を半開きにして不意にアッと声を出す際の「ア」の感覚です。
        come brother 
    ・　o / al / au / aw [ɔː]
        /ɔː/ は舌を丸めず、日本語の「オ」よりもやや口を広げて発音され
            ✖　オウ　〇オー
    ・　o を /əʊ/ と発音する場合
        /əʊ/ は唇を丸くして、口をすぼめるように発音されます。
            オウ」   あるいは 「オーウ」　に相当する発音
        open
    ・  oを/uː/と発音する場合
        ou や ow という並びで表記される語は基本的に /aʊ/ と発音する
        日本語の「アウ」に相当する発音と捉えてよいでしょう。
           例　about now
    ・母音７　i
        日本語の「イ」よりも歯と歯を離して「エ」に近づけて発音します。
        it ,lift,give,f
子音
    ・子音＋Y：dy, ty, ry, py, ly, ny（～イ）
      Rugby, Candy, Italy, Angry, Balcony, Happy, Twenty, Dizzy

    ・CK：CとKがくっついた音（ク）
      Back, Kick, Sock, Lucky

    ・PH：PとHがくっついた音（フ）

    ・IR：IとRがくっついた音（アー）　Skirt

    ・AI：AとIがくっついた音（エイ）　Paint, Spain

la ra 違い「r」「l」

    [ r ]
        舌先を軽く上あごに当てて、一瞬だけ「なでる」ような感じで 

    [ l ]
        舌先を、上前歯の歯茎にくっつける
        舌先は歯茎から離さず、のどの奥から「ウ〜」という唸り声を出す
        舌先を離す

その他の単語調べ
    ・サイジング　運用するシステムやサービスの規模に合ったリソース
    　（サーバーやネットワーク）を見積もること、あるいは用意しておくこと
    ・抽象化　「複数の情報に共通する要素を抜き出すこと」
            要点を抜く　物事の本質を捉える（認識・把握する。）ための思考法
    ・the sun compiler サン・マイクロシステムズが最初に開発したJavaのやつの由来。
    　現在はオラクルに買収されている。
    ・ニーモニック　アセンブリ言語　
    ・精通　その物事について詳しく良く知っていること
    ・同じ数を掛け合わせる回数
    ・冗長　述べ方が永田らしく、無駄のあること。
    ・保持　保ち続けること
    ・煩雑　面倒なまでに込み入っている（複雑・ややこしくなっていること）こと　はんざつと読む
    ・エポック:Dateでは経過時間の単位はミリ秒。経過時間の基準日時は西暦1970年1月1日0時0分0秒(GMT)であり、この経過をエポックと呼ぶことがある。
    ・リファレンス　
    ・論及：ある議論や説などにおいて、そのテーマと関連することや詳細まで論じること
    インライン化（インライン）
        ・inline（直列の一列に並んだ）元IT用語　
        ・その場に埋め込む
        ・programで関数などを定義したコードを、それを呼び出した箇所に展開してしまう手法を
        　  「インライン展開」「インライン関数」
        ・例、ブロック内で文字の装飾やハイパーリンクを規定することを「インライン要素」
        ・パフォーマンスの改善　プログラムの改善　サイズの縮小
        ・
    オフセット（OFFSET）    
    「えっとね～。ここを基準にしてね～。こっちにこれだけズラしたのが今の場所だよ」な位置の表し方のこと
    基準点からの距離で位置を表現したもの
    
    ・位置を表現している
    ・基準点がどこかにある
    ・距離（基準点からどれくらいズレているか）で表現している
    フラッシュする
    出力ストリームにまとめて出すこと￥

    リファクタリング
        リファクタリング (refactoring) とは、コンピュータプログラミングにおいて、
        プログラムの外部から見た動作を変えずにソースコードの内部構造を整理することである。

    コンポーネント
    構成要素。部品。
    コンピュータ機器やソフトウェアの部品。
    ステレオで、チューナー・アンプ・プレーヤー・スピーカーなどの単独の機器。コンポ。

     ニーモニックとは、コンピュータのマイクロプロセッサ（CPU/MPU）
     に与える命令の種類を表す番号（オペコード）に、人間が分かりやすいように付けられたもの

    ロケール[locale]場所、現場：分野ではシステムやソフトウェアにおける
                                言語や国・地域の設定のことをこのように呼ぶ。

    ～を返す
        呼び出し元に結果を返す　

    匿名クラス
    Java言語ではあるクラスは再利用されることはなく、特定の場所のみで利用したい場合は匿名クラスという
    実装方法がある 下記の行は　クラス定義とインスタンス化を一つの式として書いている
    例code from javaSilver紫p274,p275
    import java.util.function.Function;
    
    public class Main{
        public static void main(String[] args){
            String str = new function<String, String()>{
                public String apply(String str){
                    return "Hello" + str
                }
            }.apply("tanaka");
            System.out.println(str);
        }
    }

    ラムダ式
    構文
    (実装するメソッドの引数)　-> {処理};
    特徴
    ・ローカル変数はfinal or 事実上のfinal (i++) とかがない　必要がある。
    上記のコードのようにこの匿名クラスは冗長性があった　ラムダ式でシンプルに表せる
    ・抽象メソッドを一つだけ持つ
    ラムダ式の宣言
    ・引数の変数宣言と処理ブロックで構成される。この２つの間に　アロー演算子ー＞
    ・処理ブロックの終わりに；をつける
    ・引数が何も受け取らない場合は省略可能。　（）で
    ・引数の（）は省略可能。　（name） から　nameで。　※引数が一つの時のみ。
    ・処理の　｛｝　も省略可能。　※だだし実行したい処理が一つしかないのであれば
    ・何らかの戻り値を戻すとき、処理が一つしかなく、かつ｛｝を省略した場合には
    　returnも省略しても大丈夫
    ・ラムダ式の外からの変数をラムダ式のスコープ内から変えることは不可能。


    関数型インターフェイス　標準API
    java.lang.Comparable
    java.lang.Runnable
    java.util.Comparator
    java.util.concurrent.Callable
    java.util.function.Consumer
    java.util.function.Function
    java.util.function.Predicate
    java.util.function.Supplier
    ・・・など多数

    関数型インターフェイス
    は抽象メソッドが一つ（今回はapplyとか
    https://atmarkit.itmedia.co.jp/ait/articles/1404/30/news017.html
    ↑は関数型インターフェイスの命名パターン
    https://www.yoheim.net/blog.php?q=20160410
    https://relearn-java.com/lambda/
    ↑２はラムダ式のルール


    構文(実装するメソッドの引数)　-> {処理};
    上記コードをラムダ式で改善　リザルトは同じ。｛省略なし｝
    import java.util.function.Function;
    
    public class Main{
        public static void main(String[] args){
            Function<String, String> obj = (String str) -> {
                return "Hellow" + str;
            };
            String str = obj.apply("tanaka");//関数型インターフェイスは抽象メソッドが一つ（今回はapply()）のためラムダ式で
            System.out.println(str);            どのメソッドを実装するか判断できるため
        }
    }

    上記コード省略あり　ラムダ式
    import java.util.function.Function;
    
    public class Main{
        public static void main(String[] args){
            Function<String, String> obj = (String str) -> "Hellow" + str;//return 省略可
            String str = obj.apply("tanaka");//関数型インターフェイスは抽象メソッドが一つ（今回はapply()）のためラムダ式で
            SystemSG.out.println(str);            どのメソッドを実装するか判断できるため
        }
    }
    
メソッド参照　https://www.ne.jp/asahi/hishidama/home/tech/java/methodreference.html
    関数型インターフェイス（抽象メソッドが一つだけ定義されているインターフェイス）
    の変数にメソッドそのものを代入することができる。
    既に定義済みのメソッドを、引数なしで呼び出せることをいう　::
    Java８から導入された。
    例　


SGML
    SGML(Standard Generalized Markpu Language)
    特徴
    ・文書の電子化を目的に策定された言語　HTML・XMLの母体になる言語。
    ・５００枚の仕様書があり、あまり普及されなかった言語。　１９８０年代





ディレクティブ　コンピュータプログラムのソースコードに記述される要素の一つで、
                そのコードを解釈・変換するソフトウェア
            　　（コンパイラやプリプロセッサなど）への指示や指定などを与えるためのもの。

Javaアプレット　ホームページを見るときに使うソフト（WEBブラウザ上で）お仕事をする
                Javaプログラム　
                    ・最初はWEBサーバ（ホームページのファイルがおいてあるPC）においてある
                    ・それがホームページを見るときに自身のPCに移動してきて、仕事自体は
                    　パソコンの中でやります
                    ・性質上、セキュリティ的な制限も多い（なんでもできちゃうと情報が盗まれる）
                    ・ピヨピヨさん「個人的には、Javaアプレットのお世話になったことは、ほとんどありません。
                        はじめて訪れるホームページでJavaアプレットを実行されそうになったら、とりあえず警戒します。」

Archive　複数のファイルやフォルダを一つにまとめること
        　圧縮のことや圧縮ファイルのことを際している場合もある
JARファイル　{Java ARchive}　コンピュータプログラムを格納するファイル形式の一つ
                            Java言語で開発されたプログラムを構成するファイル群を一つにまとめて格納する
                            ためのもの　ファイル形式は　「.jar」

    用途
    ・avaプログラムを配布するための一般的な方法です。複数のJavaクラスファイル、
    　画像、サウンド、テキストファイルなどのリソースを1つのファイルにまとめ
    　ることができます。
    メリット
        ・Webアプリケーションのライブラリ：Webアプリケーションでは、複数のJavaクラスファイルやリソースファイルを含むライブラリを使用することがよくあります。このようなライブラリは、JARファイルとして配布されることが一般的です。
        独立したJavaアプリケーション：Javaはアプリケーション、JARファイルとしてすることができます。これにより、アプリケーションの移植性が高速になり、ユーザーが実行する環境に依存しなくなります。
        プラグイン：JARファイルをプラグインとして使用することができます。プラグインは、アプリケーションに追加の機能を提供することができます。
        JARファイルを使用することの主なメリットは、以下のようになります。

        依存関係の管理：JARファイルに必要なファイルをすべて失うことができるため、プログラムの実行時に必要なファイルを探しに行く必要がなくなります。これにより、プログラムの移植性が高くなります。
        の容易さ：JARファイルは、1つのファイルにすべてをまとめることが配布できるため、配布が簡単になります。
        セキュリティ：JARファイルは、署名や暗号化などのセキュリティ機能を利用することができます。これにより、アプリケーションのセキュリティを強化することができます。


boot（ブート）
PCを起動するとOSが操作可能な状態になるまで自動的に行われる処理
    詳細
    コンピューターの電源投入後、補助記憶装置に記憶されたBIOS(バイオス)という小規模な
    プログラムが実行され、オペレーティングシステムを読み込んで、コンピューターが稼働
    できる状態になるまでの一連の処理

コンスタントプールconstant(コンスタント)　Pool
    Javaの仮想マシンにおいて、定数やシンボルを保存する領域のこと　

｛｝　初期子
初期化を行う時に使う

thread(スレッド)　プログラムの処理の実行単位の一つ　　余談　話題、トピックスごとのまとまり
        https://wa3.i-3-i.info/word12453.html
        流れが一つの処理はシングルスレッド
        流れが複数に枝分かれして並行処理が発生している処理は「マルチスレッド」

スレッドセーフ
    同時進行してもぶっ壊れない物　並行処理が発生するようになっていても大丈夫なもの


バグとエラーの違い
    ・バグは意図しない書き換えによって発生するもの
    ・

フィックス　fix　IT関係
　　　「これで決まりね！」と確定しちゃうこと　　
        ・「もうこれで確定ってことにするから後でごちゃごちゃ言うな」を意図するらしい
        ・「これで終わり！」とか「これで決まり！」とか「もう何も言うな！」的な
        　　ニュアンスで使われます。

インスペクション　
    いわゆるコード検査なのですが「これがあるからJavaで良いや」と
    思わせるほど非常に強力な機能です。インテンションと異なり検査することが目的なため、
    指摘に対して必ず修正候補が出るわけではありません（指摘だけ、というものも結構あります⁠）⁠。


Windows Subsystem for Linux 2とは何ですか？
WSL 2とはWindows Subsystem for Linux 2の略で、Windows 10上でLinuxを動作させる
ための仕組みであるWSLのバージョン2といった位置付けになります。 
Windows上でLinuxを動作させられるため、システム開発等でテスト用に使われたりします。

シングルトン（Singleton）クラスのインスタンスを１つしか作成しないデザインパターン
                        のことを指す
                        特徴
                        ・静的フィールド
                        ・コンストラクタにprivate修飾子があるために外部から新たにインスタンス生成不可
                        ・唯一のインスタンスアクセスはstaticなgetterが定義されている　外部アクセスはnew
                          の代わりに　getter　を呼び出す。

直列化（serialized）
    意味：オブジェクトとそのインスタンス変数をバイト列やXML

カーソル
    拡張for文で、どの位置を取り出したか覚えているコト
    カーソルと呼ぶ。

辞書式に並べる
    https://www.youtube.com/watch?v=qaL99e28zNk
    見ろ。

エンドポイントとはhttps://smallit.co.jp/cloud-gunshi/api-endpoint-designing-uris/
    WEB上のリソースにアクセスして取得するときに使うのがエンドポイント。（URL）
    使用
    ・エンドポイントを指定してクライアント側からサーバ側に対して要求（リクエスト）とし
    　サーバ側がリクエストを受け取りそれに対して適切な処理を行い、結果をレスポンスとして返すことができる。
    中身
    ・APIを呼び出すためのURLのことで、APIにアクセスするためにインターフェースを提供する。
IPアドレスとURLの違い
    IPアドレスはインターネット上の接続機器を識別するための番号
    URLはWEB上のリソースを識別するためのアドレス

トラバース（Travers）
    　XML文書を処理する場合、通常はDOMツリーを生成し、それに
     対して要素の追加や変更などの操作を行う。こうした場合、まずDOMツリーの根
    （ルート）からたどって、ツリーを上ったり下りたりしながらさまざまな処理を
     行うことになる。この移動をトラバースという。
/*その他の単語　IT tango 単語　ここまで*/


console(コンソール)
    コンソールとは、コンピューターの操作に用いる入出力装置の一式のことである。


最近の調べたこと・資格等について
    ・資格名　Java (Bronze,Silver,Gold) まあSilverから取れ
            ・Silverをとると開発案件に入りやすくなる。
            ・給料交渉
                    特徴
                    ・価格　26,600
                    ・試験時間　150分か180のどっちか
                    ・問題数77門　80問
        ・プログラミング言語Javaの技術レベルをOracle社が認定するやつ
            正式名　Oracle Certified Java Programmer Silver SE 8 (11)

等価　＝＝　さしているものがアドレス
等値　equals 

Q疑問　なぜクラスを作る時は大文字で始まるのか
    ・英文では文中の 固有名詞 は大文字始まりですから説。
    ・昔にそういう規約があったせつ。

システムリソース　Windowsで動作するアプリケーションソフトが共通して利用する、
                  特殊なメモリ領域のことです。
ウィンドウ表示などを行うUSERリソース：アプリケーション操作で開くダイアログやウィンドウなど、
                                     ユーザ操作のための情報を格納し、
グラフィックス処理を行うGDI リソース：GDI リソースは、画面表示に使うフォントや（Windowsを構成するプログラムの一つ）
                                     ビットマップ画像、アイコンなど、グラフィックス表示関係の情報を格納するのに使われます.
USERは使う人
GDIは（Graphical Device Interface）
/*---API---*/
        APIと外部ライブラリの違い　（ネタ）
        ・
        ・
        APIとメソッドの違い
        API(Application programming Interface)で何かの機能とつなげるための仕様
        関数の形だったり、一連のメッセージだったり、URLの形だったりいろいろある
        メソッド
        自分で書いてつかう、具体的に記述して使ったりする。
    StringBuilder 
        ・+演算子を用いずに文字列を連結できる方法の一つ
        ・文字列を10万回連結した場合、約4046倍の処理が高速であるらしいp561
        特徴
        ・インスタンス化して使う
        ・バッファに格納されてtoStringで取り出す。
    /*---正規表現---*/
    　正規表現とは文字列の形式的な条件のことをいう　あいまい検索みたいなもの
    matches()同等なもの
            public static boolean isValidPlayerName(String name)
                return name.matches("[A-Z][A-Z0-9]{7}");
                //最初がA-Zの文字で　以降の文字は　A-Zか0-9　で　、文字数は8文字
    /*基本文法*/
        1.その文字でなければいけない
            String s = "Java"
            s.matches("Java")//true
        2.ピリオド:任意の１文字であれば良い
            s.matches("J.av");//.は任意の一文字。どれが入ってもいい
        3.アスタリスク:その直前の文字の0回以上の繰り返し　* 例　AB* //Bが０回以上繰り返されている。条件を満たすのは　「A」「AB」「ABBBB」 
            s.matches("Ja*va")//true　      アスタリスクはその位置の文字は何文字でもよい
        4.波カッコ:指定回数の繰り返し
            パターン    直前
                {n}     直前の文字のn回の繰り返し　             s.matches("HeL{3}O");　//　HeLLLOしか条件を満たさない　「｛」の前のLも含む
                {n,}    直前の文字のn回以上のの繰り返し               
                {n,m}   直前の文字のn回以上m回以下の繰り返し
                ?       直前の文字の０回または１回の繰り返し
                +       直前の文字の１回以上の繰り返し
        5.角カッコ:いずれかの文字
            パターン中に角（[]）で囲まれた部分がある場合、その中のどれか一文字にあてはまる必要がある。
                例:"UR[LIN]"//一文字目がU、２文字目がR、３文字目がL,I,Nであることを指す。
        6.角カッコ内のハイフン:指定範囲のいずれかの文字
            角カッコ内にハイフン記号(-)が含まれている場合　その両端にある場合
            の一文字をしていする。
            なお、すべての数字([0-9])など多用されるパターンは　\
            定義済みのクラス例 ※あんま使わない可能性あり
                ¥d　いずれかの数字　[0-9]
                ¥w  英字・数字・アンダーバー　
                ¥s　空白文字（スペース、タブ文字、改行文字など）
        7.ハットとダラー　先頭と末尾
        　例えば　"^j.*p$"  //先頭文字がjで最後の文字がpの任意の長さの文字列
        
            split:文字列の分割　一つの文字列の分割
        String s = "abc,def:ghi";
        String [] words = s.split("[,:]"); //[,:]は正規表現パターン
        for(String w ; words)
            System.out.println(w + "->");      //実行結果　abc->def->ghi->
            
            replaceAllメソッド:文字列の置換
                Stringクラスであり、文字列中のパターンに一致した箇所を別の文字列に置換できます。
        String s = "abc,def:ghi";
        String w = s.replaceAll("[beh]","X"); //置換したい文字列　beh 　置き換える値　X
            System.out.println(w);      //実行結果　aXc,dXf:gXi

    文字列の書式整形
    format
        特徴
        ・静的メソッド
            ・静的メソッドは static がつき　メソッド自体がクラスに属する・インスタンスにメソッドの分身が準備される。
        ・毎回lengthメソッド使って自力で空白を入れて桁をそろえるのは面倒
         それを簡単にする
        
    use
    String.format("%d日で%s分かる%s入門",3,"スッキリ","Java")//3日でわかるスッキリJava入門
    System.out.printf("%d日で%sわかる%s入門",3,"スッキリ","Java");
    //結果は上記の行のほうがわかりやすい
        //補足"%d・・・入門"書式指定文字列（ひな形を指定する） %はブレースホルダと呼ばれる。
    　  %はプレースホルダ(place holder)place:場所、位置　holder:入れ物、保有者当
    プレースホルダ書式
        %修飾(省略可) 桁(省略可) 型(必須)
            修飾
                ,   3桁ごとにカンマを入れる
                0   空き領域に0を埋める
                -   左寄せ
                +   符号を強制表示
            桁
                表示桁数を指定する。
                n.m形式で指定した場合、全体n桁,少数点以下m桁での表示となる
            型
                d・・・整数
                s・・・文字列
                f・・・少数
                b・・・真偽値

    /*---日付と時刻---*/
        ・Javaでは４つの形式が用意されており、時と場合で使い分ける。
        　基準日時1970年1月1日0時0分0秒　これを　エポックという
        形式１:long型の数値
                ・経過したミリ秒(1/1000秒)数で日時情報を表現する方法
                 特徴
                    ・long型の形式はシンプルでJVM内部で扱いやすい
                    ・long型は日付情報以外の数値の格納にも利用あれる型なので
                    　必ずしも変数の中身が日時情報だと断定できない問題もある。
                 use
                    long s = System.currentTimeMillis();//long型の数値　変数ｓに代入        
        形式２:Date型のインスタンス
                形式１のlong型の課題を克服するために広く用いられているのがjava.util.Dateクラス
                 特徴
                    ・このクラスは内部でlong型の値があるだけ。
                    ・Javaで日時の情報を扱う場合に最も利用される形式。
                 use
                    //importしておくと便利になる。
                    import java.util.Date;
                    //現在日時によるインスタンス生成
                    Date a = new Date();
                    //指定時点の日時を持つDateインスタンスの生成 ※家でやる：値のほうを調べる。
                    Date d = new Date(long 値);
        形式３:Date人間が指定しやすい「6つのint形式」
                前述のSystem.currentTimeMillisメソッドを使うか、Dateクラスをnewすれば,「現在の時刻は簡単に得られる。」
                しかし、画面に時刻を表示する場合、「2022年9月22日1時23分45秒」のような文字列にするためには
                「年・月・日・時・分」をint型で指定することが一般的
        形式４:人間が読みやすいString型インスタンス
                機械が扱いやすいのは long型 Date型
                人間が扱いやすいのは 文字列型と6つのint型　p582
        /*---日付と時刻の課題---*/　p582
        古くからある古参API
        課題(１)Date型と6つのint値の相互変換の解決
                java.util.Calenderクラスが用意されており
                特徴
            /*---Date型---*/※クラス
            //現在のデータ取得
            Date d  = new Date();
            /*---Calendargata型---*/※クラス
            //Date型と相互変換を行うためのもの
            Calendar c = Calendar.getInstance();
            Date d = new Date();
            System.out.println(d)//この行が実行された時の時刻を表示する。
            c.set(2029, 11, 1, 23, 45);
            d = c.getTime();//値の取得　　※インスタンス化と同時に値を取得してもOk　下記
            Date d = c.getTime();//c.set(年,月-1,日,時,分)//月は０月(１月)から始める。
            System.out.println(d)//Sat Dec 01 23:45:02 JST 2029
        
        課題（２）Date型と文字列型の相互変換の解決
                 java.text.SimpleDateFarmat();
                 java.text.SimpleDateFormatクラスが準備されている

                /*--StringからDateインスタンスを生成する。--*/
                SimpleDateFormat f = new SimpleDateFormat(書式文字列);
                Date d = f.parse(文字列);//parseは解剖する　文法的関係を説明する。
                /*--DateインスタンスからStringを生成する。--*/
                SimpleDateFormat f = new SimpleDateFormat(書式文字列);
                String s = f.format(d);//dにはDate型変数を指定する。
                例文
                public static void main(String[] args) throws Exception{
                SimpleDateFormat f = new SimpleDateFormat("yyyy/MM/dd HH:mm:ss");
                //文字列からDateインスタンスを生成
                Date d = f.parse("2022/09/22 01:23:45");//(souce)を分解{parse}してDateインスタンスに格納
                System.out.println(d);
                //Dateインスタンスから文字列を生成
                    Date now = new Date();
                    String s = f.format(now);//String型の変数ｓにｆのフォーマットとしてDate（現在の時刻）を格納
                    System.out.println("現在は"+ s +"です。");
                }
                /*--書式文字列--*/
                "yyyy/MM//dd"や"yyyy年MM月dd日"のように、日付の書式を指定する。


                /*---書式文字列として利用可能な文字（一部---*/
                y:年　　H:時(0‐23)　　　k:時(0‐11)
                m:月　　m:分　        　E:曜日
                d:日　　s:秒           a:午後/午前
        しかしこれらは古参APIであり、機能的限界がある。
            ・最小でも「ミリ秒」単位でしか時間を扱えない※ナノ単位で動くPCにとってミリは長すぎる
            ・私たちが日常利用する「曖昧な日時」や「時間の幅」を表すことができない。
        /*---tiem API---*/Standardtime.java
        前述を克服するためのAPI、Java８から追加　Java.timeパッケージ
        曖昧なタイムゾーンの情報が欠落している　「曖昧な日時」　を表現できる。
        
            タイムゾーンとは
                簡単に
                    ・地球上で同一の標準時を採用している地域の集合のこと。　イギリスロンドンみたいな
                    ・コンピュータ間でどの地域の標準時で運用するか定めた設定項目
                詳しく
                    ・タイムゾーンは軽度15度ずつ１時間ごとに分かれているが、UTC協定世界時（イギリス基準で）　
                    ・だが、国や地方の境界にしたがって何分ずれているかわれている。

        表　Java.timeパッケージの代表的クラス
        クラス名                    機能と役割
        Instant                    世界における、ある「瞬間」の時刻を、ナノ単位で厳密に指し示し、保持する。
        ZonedDateTime              上記同様//Zoned地域、地帯、区域
        LocalDateTime              日常的に使われる「曖昧な日時」を保持する
        Duration                   ２つの異なる時刻や日付の期間を保持する。
        Period                     上記同様//Period(ピュリエード)時代・次期、１区切り
        

        /*---特定日時を指し示すクラスで共通に利用されるメソッド---*/
        now()           静的メソッド　現在日時からインスタンスを生成する
        of()/of～()     静的メソッド　他の種類から交換してインスタンスを生成する
        parse()         静的メソッド　"2020/4/12"などの文字列からインスタンスを生成する。文字列書式は
                                    　DateTimeFormatterで指定する
        format()                      保持情報を"2020/04/12"のような文字列に変換する。文字列書式はDateTimeFormatter
        get～()                       格納する年や月の情報を取得する。「～」部分には、Year、Month、DayOfMonth,Hour,Minute,Second,Nanoなどが入る
        isAfter()                     引数で渡したインスタンスとの前後関係を判定する
        isBefore()                                  ””上記と同様
        plus～()                      指定したぶんだけ未来または過去の時点を返す。Years,Month,Day,Hours,Second,Nanos
                                    　//期間、段階、　　持続間隔
        minute～()                                  ”” //上記と同様
        plus()/minute()               指定した時間間隔(後述のPeriodやDuration)ぶんだけ未来または過去の時点を返す

        Instansクラスについて
            特徴
            ・新しい」日時API　瞬間を意味し、エポック（現在の時刻）を格納することができる。
            ・ナノ単位で表すことが可能
        ZonedDateTimeクラスについて//Zoned　地域、地帯、区域
            特徴
            ・瞬間を格納できるクラス。
            ・エポックからの経過時間ではなく、例：東京における西暦2020年8月10日7時11分9秒392661ナノ秒という形式で格納
            ・どの都市の人を基準にするか明確にするために    time zone   と呼ばれる情報が入っている。
            　「Asia/Tokyo」「Europa/London」などの文字列で表現される　これらの管理はIANA国際標準化団体
        
        和暦を扱うAPI　Time API の　java.time.chrono.JapaneseDate を用いると
                                    令和何年何月何日　を扱うことができる。
        
        同じ瞬間の判定には
        isEqual(イズイークアル) 同じ瞬間の判定には、isEqual()を使う。

        LocalDateTime
            特徴
            ・タイムゾーン情報だけは格納しない
            ・このインスタンスはどの瞬間を指し示しているのかを確定できないが「曖昧な情報を格納」
            　する意味では最適クラス
            ・通常のプログラムではこっちを使う。    


/*---Java APIリファレンス について---*/
    ・Javaのリファレンス(参考文献)はオラクル社が公開しているJavaを開発するために
    　必要な情報が書かれているドキュメントのことを言う
        基本ドキュメント
        ・Java　SE(Java PlatForm, Standard Edition)//Javaの開発基盤・（標準・基準）・版
        　及びJDK(Java　Development　Kit)Javaのプログラムを作るときに必要な、あるいは、あると便利なあれやこれやを詰め合わせたもの
                Javaは人間が書いたソースファイルをコンパイルを通して機械語に翻訳する
                javac は実際にはJavaのソースファイルをコンパイルするという使命を持ったプログラム
                    実行するとjavac.exeという名前が仕事する。
        に関するドキュメントの一覧があるページ
        more Detail(もっと詳しく)
        ・javaFX APIドキュメント
            なぜFXなのか
                由来は公式にはないが　Special Effects（特別な結果・効力・効き目・感銘） が訛った物だと言われている
                スペシャル エフェクツ －＞ エフ・エクツ －＞ エフ・エクス －＞ FX
            ・Java仮想マシンで動作するＧＵＩライブラリのＡＰＩドキュメント
        ・Java言語および仮想マシン仕様
            ・仮想マシンの仕様マシンについて
    ・ツール関係のドキュメント
        UNIXでJava　Plat /*づつきはみたいときに*

//15－11
//家でやる

/*this super*/
    this はこのオブジェクトについて　
    Javaのthisは二つの用途がある
        ・オーバーロードされた別のコンストラクタをを呼び出すときに使うthis
        ・インスタンスそのものを表す参照を入れる特別な変数として使う場合。　例Sample.this()
            これはそのインスタンスが持つSampleというメソッドを呼び出さそうとしている。
    オーバーロードしたコンストラクタから、別のコンストラクタを呼び出すにはthisを使う
        public class Sample{//JavaSilver 黒本　p216
            public Sample{
                this(null,0)
            }
            public Sample(String str, int num){
                System.out.println("呼び出された。")
            }
        }
    上記のコードの　this(null,0)をなぜSample(null,0)にしないのかというと、
                    外部クラスがインスタンスを生成する時に使用するコンストラクタを
                    指定するための方法だからだ。






superは　スーパークラスのオブジェクトについて
    例
    this.name = name;//このクラスのオブジェクトついて
    super.name = name;//継承元（スーパークラス）についてのやつ
/*---デバックについて---*/
    ブレークポイントについて
        意味
        ・ブレークポイントとは、コンピュータプログラムを実行する際に開発者の指示で強制的に実行を
        　一旦停止する箇所のこと。
        use
        ・プログラムの開発時に設定される
        特徴
        ・不具合の原因などを探るために用いられる
        ・その瞬間の変数の値やCPU内部のレジスタの内容など
        　プログラムの実行状態を詳細に調べることができる
        詳細
        ・開発者はデバッカなどの開発支援ツールを用いて、ソースコード上の特定の行や文を
        　ブレークポイントに指定してプログラムを起動するとその位置の命令が実行される直前に
        　中断される。

/*---Javaの用語について・構文関連---*/
    <? extends ...> や　<? super ...>って何　暗黙型変換の例とdoubleとint型のキャスト例を出すとわかりやすい
    準備prepare(プリペアー)
    class A {}
    class B extends A {}

    <? extends E>　について　https://qiita.com/sukoyakarizumu/items/a95d88e294940c31b6fc
        <? extends E> はE型のすべてのサブクラスを表している。だから、
        <? extends A>が表すクラスは<? extends B>が表すクラスをすべて
        含んでいることがわかる。この性質があるので、以下の代入関係が成り立つ：
            List<? extends A> listA;
            List<? extends B> listB;

            listA = listB; //OK
            listB = listA; //コンパイルエラー
            <? extends B>はクラスAを含んでいないので、listBにlistAを代入することはできない。
            代入できてしまうとキャストが必要になり、型安全でなくなってしまう。
            また、<? extends E>はE型自身を含むので、以下の代入関係も成り立つ：
            List<? extends A> list1;
            List<A> list2;

            list1 = list2; //OK
            list2 = list1; //コンパイルエラー

    <? super E>　について　上記と同じリンク
    <? super E> はE型のすべてのスーパークラスを表している。だから、
    <? super E>が表すクラスは<? super A>が表すクラスをすべて含んでいることがわかる。
    この性質があるので、以下の代入関係が成り立つ：
    List<? super A> listA;//ソース
    List<? super B> listB;//ソース

    listA = listB; //コンパイルエラー
    listB = listA; //OK
    また、<? super E>はE型自身を含むので、以下の代入関係も成り立つ：

    List<? super A> list1;
    List<A> list2;

    list1 = list2; //OK
    list2 = list1; //コンパイルエラー

    <?>
    <?> はすべてのクラスを表している。つまり、<? extends E>や <? super E>なども含めて、すべてのクラスを代入することができる。

    List<?> list1;
    List<? extends A> list2 = null;
    List<? super A> list3 = null;
    List<A> list4 = null;

    list1 = list2; //OK
    list1 = list3; //OK
    list1 = list4; //OK
    <? extends Object>
    <? extends Object>は、Objectのサブクラスを表しているので、<?>と同じくすべてのクラスを表している。よって、<? extends E>とは異なり、<? super E>を代入することができる。

    List<? extends Object> list1;
    List<? extends A> list2 = null;
    List<? super A> list3 = null;
    List<A> list4 = null;
    List<?> list5 = null;

    list1 = list2; //OK
    list1 = list3; //OK
    list1 = list4; //OK
    list1 = list5; //OK

    Signature//著名などの意味
    シグニチャ／シグネチャ　引数の数、（引数の型、並び順）が含まれている
    staticメソッドとインスタンスメソッドのシグネチャは同じにできない

/*---ジェネリクス型の上限・下限境界とスーパーバウンド（ワイルドカード時もあり）---*/
    定義
    ・「サブタイプ」継承関係においてある型が別のサブクラスであることをあらわす　要はスーパータイプが別の型としてみることもできることをあらわす。
    ・上限境界とはジェネリックスで使用される型パラメータに対して、そのパラメータの「サブタイプ()」を指定する
    　制約のことを指す。スーパーバウンドの概念の一つ
    ・下限境界はsuperで指定される。そのスーパータイプのみが使用可能である。<>
    ・スーパーバウンドはジェネリックスで使用される型パラメータに対してスーパータイプ
    　を指定する制約のことを指す概念
        //How superbound come into existence（イグジステンス）存在するようになっta
        ・型の安全性が担保される。実行時の型エラーの回避
    https://java.keicode.com/lang/generics-super-bounded.php
    
    上限境界は<T extends クラス名>のようにあらわされる。
        ・代入できるのはクラス名を継承しているクラスのみであり、継承しているサブクラスのサブクラスを代入することは不可。
    ワイルドカードを使用時
        <? extends クラス名>
        ？に代入可能なのはクラス名とクラス名のサブクラスのサブクラス
        //疑問　 ・クラス名を継承したサブクラスのサブクラスはクラス名のmethod fieldを受け継いでない

ジェネリクスとは、プログラミング言語の機能・仕様の一つで、同じプログラムコードで様々なデータ型のデータを処理できるようにするもの。 
    ボックス化（boxing）とは、プログラミング言語において値型をオブジェクト型（参照型）に変換すること。

イテレータとは、プログラミング言語の機能の一つで、
配列のようなデータ構造の要素を順に走査走査(スキャン)とは、
対象をなぞることで対象物の情報を得ることしていく
繰り返し処理を簡潔に記述できる構文やオブジェクトなどのこと。
    イテレータ（iterator）はコレクションクラス中身を順に取り出すための専用の道具を用いた方法
                    イメージ：リストに含まれる１つの箱を「ここ！」と指している矢印のようなもの
                        呼び出すと先頭よりもっと前をさした状態　０番目よりー１した感じになる
                    ※拡張for文に渡せるようにするためのインターフェイス　
                    　実装してれば拡張for文に渡せる
整数を格納<>//
/*---ジェネリクス---*/https://camp.trainocate.co.jp/magazine/java-generics/
構文
    ➀class名<型パラメータ>　= new class名<>();
    ➁
特徴
    ・様々な型を入れられる物に対して型を限定できる。
        String型のジェネリクスで宣言したのに整数を入れようとするとコンパイルエラーが発生してよい。
        ※前はコンパイル通って実行エラーが出ていた。
    ・何の型を扱っているのかがわかりやすい
        ジェネリクスが出てくる前はリストに入れておくべき型が何かわからなかったので変数名や他のコードからリスト
        に入れる型を推測するのに使っていた。
    ・データ型の不一致による実行時エラーを妨げる。
        前の型
        ジェネリクスが誕生したことでキャストが自動で行われるこ都になった。これにより、安全に利用することが可能になる。
            例　List<String> chars = new ArrayList＜String＞()


<>はジェネリクスと呼ばれるJavaの文法の一種　おもにインスタンスの中身に値を格納したいとき　コレクションクラスにつかう
<T> クラスやメソッドにつける「型パラメータのこと」　Class<T>           ジェネリクスクラス
                                                   pulic <T> void... ジェネリクスメソッド
    <T>は<Type parameter>の略 
        特徴
            ・総称型の一種である。
        使い時
            ・インターフェースを作成する際など　「具体的なデータ型がまだ決まっていない時」がある。
                そんな時につかう。
    <T>のいろいろな呼び方
    <T>といっても何を入れるかをプログラマにわかりやすくしたのがいろんな呼び方につながったという
    一般的に使用されている型パラメータ名を紹介します。

    E – Element（要素）(Javaのコレクション フレームワークで多用されている)
    K – Key（キー）
    N – Number（数値）
    T – Type（タイプ） 
    V – Value（値）
    S,U,V etc. – 2番目、3番目、4番目… types
    書き方の種類。

コレクション　データやオブジェクトなどをまとめて格納するための
                    データ構造やクラスなどの総称をコレクション
                    ※何らかの集合をいう。
    制約　コレクション　※　コレクションはこれらを基本的にカバーしてる　ArrayList
    ・同じ型、もしくは互換性のある型しか使えない
    ・扱える要素数を最初に決めなくてはならない。
    ・要素にアクセスには添え時を使わなければならない
    ・要素アクセスの際には、要素数を超えないように配慮しなければならない。
        現場
        ・コレクションAPI
        ・コレクション・フレームワーク
    基本データ型は格納できない
    ・コレクションクラスは宣言時に準備する箱の数を指定しない
        データを追加仕様とした際に箱の数が不足していれば、かってに追加される。
            要素は随時

pref prefecture 
(フランス・日本などの)県、府、知事官舎、長官 の職

wrapper class (ラッパークラス)８つの基本データがたに対して　「基本データ型の情報を中身に保持すること」
                              を総称してラッパークラスと呼ばれる
    使いどころ
    ・基本型を参照型（オブジェクト）として扱えるようになり、用意されたメソッドを使って値に対する処理を
    　行える用になる
        例
        ・「文字列として入力された２つの値を使って計算処理をしたい」
            文字列の数値をラッパークラスを利用して基本型に変換し計算を行う。

オートボクシング(Auto Boxing)Integer（整数）などのラッパークラス型インスタンスとint型のよ
                            うなインスタンスとint型のインスタンスを自動で変換してくれるもの
オートアンボクシング(Auto an Boxing)上記同様　int型の格納は無理　ArrayList＜Integer＞

ローカル変数型推論　Java10以降はローカル変数を簡略化できるようになり、これまでintなどの型名を記述していた部分にvarを記述すると、その変数は代入された値の型として使われます

ストリーム　小川、流れ、連続などの意味を持つ英単語　https://codezine.jp/article/detail/6299
        Javaではデータの流れや、その通り道を意味する
        　　ストリーム　入出力の仕組みを返しているもの
    種類    Javaからの視点
    ・入力ストリーム  読み込み
    ・出力ストリーム　書き込み
入出力処理について
    入出力処理はプログラムと外部とのデータやり取りのこと。
        Javaはこの入出力処理をストリームという仕組みを返して行っている。　java.ioのpackageで提供
            ・ファイルへの書き込みやファイルからの読み込みのことの入出力。
    

エンコーディング（符号化）　データを一定の規則にしたがって目的に応じた情報に変換すること。
                　変換された情報を符号（encode）、変換することを符号化（エンコーディング）と呼び
                　データへ戻すことを複合（デコード）と呼ぶ
    特徴
    ・規則にしたがってデータを変換すること　例　英語以外のテキストの場合にほかの言語の国の人が読めないといったことを解消するために指定してあげる
    ・誰でも読めるようにエンコーディングは必須
    ・Unicodeは多くの言語に対応している。

Unicode　は世界中の文字を扱えるようにした文字コードである。　厳密には文字集合
    符号化方式
    UTF－１６　UTFー８　持っている文字の種類は同じ
コンバータ（converter）何かを何かに変換する機械やプログラム

    間接型インターフェイス　引数が Predicate(述語　基づく)になっているもの　断言する
    　java.util.function 

/*---errow・Exception(IOE)---*/
    １Errow系例外
    　java.lang.Errowの子孫 回復みこみがない
    ２ Exception 系例外
    　java.lang.Exceptionの子孫　その発生を十分に想定して対処を考える必要がある例外的状況
    ３ RuntimeException 系例外
      java.lang.RuntimeException クラスの子孫　必ずしも常に発生を想定すべきとまでは言えない
                                 例外的状況を示す
    /*例外クラス*/
    Java言語の例外クラスは２種類に分類
        checked例外     DBなどJava実行環境以外の環境が原因で発生する例外。
                        ※処理が必須
    
        unchecked例外   実行中のプログラムが原因で発生する例外（実行時例外）　メモリ不足の
                        プログラムの例外処理では復旧できない例外。　主にHDに原因あるかも
                        ※処理が必須ではない

    例外クラスは３種類に分類される
    ・Errowクラスおよびサブクラス（unchecked　例外）
    ・RuntimeExceptionクラスおよびサブクラス（unchecked　例外）
    ・RuntimeExceptionクラスおよびExceptionのサブクラス（checked 例外）　必須

    複数のcatchブロック定義JaSiPa
    ・catchブロックで指定した例外クラスに継承関係がある場合は　「サブクラス側」先に書く
    　スーパークラスクラスから書くとコンパイルエラーになる
    例code
    } catch(NullPointerException　e){
    ...
    } catch(Exception　e){ }

    継承関係のない例外クラスは一個一個書書かずともすむ
    } catch(FileNotFoundException | ArithmeticException　e){
    ...
    } catch(Exception　e){ }

        到達不可能な構文は
/*errowの対策*/
文法エラー(synatax errow)
実行時エラー(runtime errow)
・パソコンのメモリが足りなくなった
・存在すべきファイルが見つからない
・null(価値がない)が入っている変数を利用しようとした
    これらの状況に共通すべき点はプログラマがソースコードを作成する時点では例外的状況の発生を予防できていない

エラー　シンボルが見つかりません　変数にアクセスできないとか

throws宣言とtry-catch-syntax(構文)
　メソッド内で例外が発生する場合に、そのメソッド内でキャッチしない場合throws宣言で
    再スローしてやること
    例えばメソッドが呼び出されて呼び出し先にこう書いてあったらこの例外処理はここでは処理しませんが、呼び出し元が処理します
    　　　ということになる。
    例外とは通常の処理では考えられないようなもの　エラー
    ・例外を発生させることを「例外を投げる（throw）」
        例外が発生する場所
        ・明らかに発生する場合もあるが　わからない場合もある
    ・例外の補足
    try (試す) キーワードと、catch (捕捉) キーワードを使うと、例外を捕捉できます。
　たとえば、上の例で発生するかもしれない例外を捕捉するために、以下のようなスクリプトを書くことができます。
        try // 例外が発生するするかもしれないので
            {
                func1(); // ここでは例外が発生するかもしれない
            }
            catch // 例外を捕捉する
            {
                // 例外がおきたとき、ここが実行される
                inform("画像を読み込むことができません。"); // メッセージを表示する
            }
            このように、try のブロック内で例外の発生するかもしれない処理を書けば、例外がおきたときに catch のブロックを実行することができます。
            エラー処理をこのようにすっきりと書くことができます。
            　try のブロックでなにも例外が起きなかった場合は、catch のブロックも実行されません。
            　try のブロックでは何でも書くことができます。この例のように、はっきりとその行で例外がおきる可能性があることもありますが、関数呼び出しのそのまた関数呼び出しの先で例外が発生したときも、
            　try ... catch を書いておけば例外が発生した時点でここに戻ってくることができます。
            　例外が発生した場合は、ブロックの残りの処理は中断され、try のある場所まで戻ってきます。
        例外オブジェクト
        例外に関するさまざまな情報が、Exception というクラスのオブジェクトとともに
        投げられてきます。このオブジェクトを例外オブジェクトと呼びます。これを、catch で受け取ることができます。
　      たとえば、以下のようなスクリプトを書くことができます。
        例:
        try
        {
            loadImages("nothing.jpeg"); // 例外が発生するかもしれない処理
        }
        catch (e) // e という変数で例外を受け取る
        {
            // e.message は、例外とともに投げられたメッセージ文字列を表します。
            // これには例外が発生した理由が説明されている場合があります。
            inform("画像を読み込むことができません。\n"+e.message);
        }
        throw ステートメント
    　例外を投げることもできます。例外を投げるには throw キーワードを使います。
    　たとえば、以下のようなスクリプトを書くことができます。
        例:
            function pow2(n)
            {
                // 2 の n 乗を計算する n は正の整数でなければならない
                if(n<0) throw new Exception("負の数は指定できません。");
                    // ↑ 例外を発生する
                return 1<<n;
            }
        例外を再び投げる
        　catch で例外を捕捉したのはいいが、まだ例外を受け取る可能性のある try がどこかに宣言されているかもしれない、そのような場合に例外を再び投げることができます。
        　以下のようなスクリプトを書くことができます。

            例:
                function tryloadimage()
                {
                    try
                    {
                        primaryLayer.loadImages("test1.bmp"); // test1.bmp を読んでみる
                    }
                    catch(e)　　　　　
                    {
                        inform("画像読み込みに失敗しました。");
                        throw e; // メッセージを表示はするが、例外を再び投げる
                    }
                }

                function test()
                {
                    // tryloadimage を呼び出し、画像読み込みが成功すれば true
                    // そうでなければ false を返す関数
                    try
                    {
                        tryloadimage();
                    }
                    catch
                    {
                        return false;
                    }
                    return true;
                }

            　ここで test() を呼び出し、画像読み込みに失敗した場合は、inform メソッドによりメッセージが表示されますが、再び例外が投げられるため、test 関数内の catch により捕捉することができます。
            　

Spring Frameworkについて
　特徴　https://www.sejuku.net/blog/10456
    ・JavaのWEBフレームワークで、WEBアプリを作ることができます。
    ・DI(Dependency Injection）と呼ばれる仕組みが導入されています。
    　日本語でいうと、「依存性の注入」
    ・テストが簡単　「Spring MVC Test」という専用のテストプログラム
    ・拡張性が高い
    ・保守性が高い
    ・WEBサービス

ストリーム　川の流れみたいなものp694
    ・Javaはファイルを少しずつ読み書きしている小川を通して上流にあるファイルから
    　少しずつ文字が流れてくる。
ロジックツリー　　マイリスト
https://twitter.com/miha_programmer/status/1624928154241601537?s=20&t=SWuedKuXlUrh-waFkYQ0rw

/*ライブラリで提供されている物を使う時*/
使用したいメソッドやコンストラクタがまずThrows指定されているか見る
    指定されている場合は例外クラスの継承関係を見て必須・任意を判断する　javaSilver紫p312
    ErrowクラスとRuntimeExceptionをスーパークラスクラスに持っていたら任意
    
    Throwsは指定された例外クラスのオブジェクトがメソッド内で発生した場合、その例外オブジェクト
    はメソッドの呼び出し元に転送される
    
    ThrowはJava言語で提供されてる例外クラスや独自例外クラスをインスタンス化した例外オブジェクトを
    任意の場所でスローできる

/*---モジュール・システム---*/
    Java9より導入　2017年9月
    モジュールはパッケージの上位に位置ずけられ、そのパッケージをさらにグループ化する
    パッケージへのアクセス制御　https://snownotes.org/what-is-entry-point/
    ・モジュール化の目標
        ・信頼性の高い構成
        ・強力なカプセル化
        ・スケーラブルなJavaプラットフォーム｛スケーラブルはシステム等の拡張性・可能性｝
        ・プロットフォームの整合性の工場
        ・パフォーマンスの向上

    Java9からは９以降はJavaSEが提供する基本的なAPIもモジュール化されている
    ・Java.base 
        Java SE PlatFormの基盤となるAPI定義　Package Java.lang,java.text,java.util
    ・Java.desktop
        AWTとSwingなどのGUI関連のAPIを定義  　Packege　java.awt, java.swing
    ・Java.spl
        JDBC APIを定義　                    Packege　java.sql, javax.sql 

    モジュールとは　関連するパッケージ、リソース（イメージファイルやXMLファイルなど）
                　　モジュール記述子（モジュールの名前・依存性）の集まりです

    cmd module 
    -q　--module-path   モジュールが格納されている場所をしていする　{アプリケーション・モジュールを検索する位置を指定}
                        現在の場所であれば（.）カレントディレクトリ（現在いるディレクトリ）を指定する

    -m --module         モジュール名とエントリ・ポイントとなるクラス（main）を含むクラス
                        ｛モジュール名とエントリ・ポイントとなるクラスmainクラス｝を指定
                        の完全修飾名を指定する　このオプションによって　
                        ルート・モジュール（アプリケーションの起点になるモジュール）を指定
                        ※モジュール名を含めたクラスを実行するためには　
                                    モジュール名/クラスpath　で実行する
    -d                  クラスファイルの生成場所を指定する　現在の場所から指定
    --show-module-resolution モジュール解決の様子を出力　
    ../ 一つ上の階層

    クラスパス　Java実行環境がクラスおよびほかのソースファイルを検索するぱす
                JDKツールを呼び出す時に
    エントリーポイント　（侵入の起点）https://snownotes.org/what-is-entry-point/
                プログラムが実行される最初の場所。一番最初に呼ばれるメソッドになる。
                Javaで言うとmainメソッドがエントリーポイントとなる。

/*---...　可変長引数について---*/
    可変長引数はその数を自由に変更できるメソッドのこと
    可変長引数を扱う時は配列と同じような大カッコでやる【】
    　可変長引数を扱うときの注意点
        ・同じ型で数の可変な引数をまとめられるだけで、異なる型はまとめられない
        ・可変長引数以外の引数を受け取る必要がある場合は、可変長引数を最後に書くこと。
            ※↑はコンパイラがどこまでが第１引数でどこからが第２引数なのかが理解できないため。
    void Sample(int... num){}

/*---return文について---*/
return文は呼び出し元のメソッドに値を戻すと呼び出し元に制御を戻すがある
        呼び出し元に制御を戻すはそのメソッドでの処理を強制終了し、呼び出し元のメソッドに戻るということ
            要は何もしないで制御だけを返す

コンパイルエラー　到達不能なコード
    void sample(int num){
        return;
        System.out.println("上でもう強制終了し元に戻しているので現在のコードは出力されません");
    }

/*---　クラス宣言 ---*/
クラス宣言時に使えるアクセス修飾子は
    ・public
    ・指定なし
/*---　内部クラスについて　---*/ JavaSilverのinner.java参照
インナークラスの場合は(内部クラス)ault
    インナークラスはクラスの中aultにクラスを定義する内部クラスのこと
        ・内部クラスはクラスをメンバーと同じように扱うことができる。
        ・内部クラスからは同じクラス内のフィールド変数、メソッドを参照することができる。
        ・privateがクラス宣言に使える。
    使用方法
    ・外部クラス名　外部クラスのオブジェクト名　＝　new 外部クラス名（）;
    ・外部クラス名.内部クラス名　内部クラスのオブジェクト名　= 外部クラスのオブジェクト.new内部クラス名();

/*---　オブジェクト型変数について　---*/
オブジェクト型変数が持つことができるのはオブジェクトそのものではなく
インスタンスへの参照（リンク情報｛つなげる情報｝）そのため、メソッド呼び出しの引数
として、オブジェクト型変数を渡した場合には、変数が持っている参照がコピーされて渡される。
    参照はコピーされたものを渡され呼び出し元と呼び出し先のメソッドは異なるが、
    それぞれの参照先にあるインスタンスは同じ物であることには変わりない　
/*---　オブジェクト指向（OOA）やオブジェクト指向設計について（OOD）　---*/
    モデリング手法
    ・CRC　Class, Responsibility, Collaboration（クラス、責任、協力）の頭文字
        CRCカードは、クラス図を作成する前に、システムに必要なクラスを特定し、
                    それらのクラスの責任と役割を明確にするために使用されます。
            詳細説明
                ・担当する責任、そのクラスが協力する他のクラスのリストが
                記載されます。CRCカードは、チームメンバーとのコミ
                ュニケーションに役立ち、開発プロセスを促進し、システムの正確な
                モデルを得るために使用されます。

/*---　疑問　---*/
    オブジェクトとクラスの違いについて教えて
    ・クラスはオブジェクトの設計図である。
/*---　サーブレットについて　---*/https://agency-star.co.jp/column/tomcat
サーブレット（servlet）はWeb上のサーバでJavaを実行する
主なサーバーとしてよく使用されている
    ・基本動作
        ・クライアントがサーブレットにリクエスト発行→servletのServiceメソッドの呼び出し
        ・最初にサーブレットはリクエストがGetメソッドかPostメソッドかを判定する
        ・GET・Postメソッドともにサーブレットリクエストインスタンスとサーブレットレスポンスインスタンスを引数にとる
        ・上記の要素を2つのどっちかのメソッドで処理してクライアントに返す
    ・Apache（安定する）
        ・フリーソフトであり世界中で使用されている高い信頼性と充実した昨日
        　を備えたWEBサーバーソフトウェア（HTTPserver）

WEBコンテナについて
    Javaで作成されたWebアプリケーションを動かす為には、プログラムを解析
    して処理する実行環境が必要。
    ↓
    Webアプリケーションを動作させる為の実行環境はJ2EEを組み込んだWebコンテナとして提供される。
    ↓
    サーブレット/JSコンテナともいう。
    
    メジャーなもの　Tomcat（Tomcat自体Javaで作成されている。）
        ・動作
            ・検索エンジン等の入力された値をもとにリクエストさえた処理を実行し
            　結果をブラウザに表示するような処理
            ・他のWEbコンテナとして「Glassfish」「Jetty」がある。
サーブレットコンテナ
    ・サーブレットの実行環境の提供を行う。
    ・サーブレットの起動から破棄されるまでの一連のプロセスを管理する
コンテナ
    ×　コンテナ＝ＪＤＫorJREのようなライブラリ　×
    〇　コンテナ＝サーブレットを実行する為のセットが全て詰め合わせになっている
/*---JSP---*/
    HTMLとJavaを一つのファイルに記載したもの。「.jsp」

/*---JSP and web.xml---*/
web.xml存在意義　：　Webアプリの設定や動作を制御する。
詳細    セキュリティ設定、フィルター、URLpatternとmapping、初期化パラメータ
webコンテナ(サーブレットコンテナ)https://ryonotes.com/relationship-of-servlet-and-container/
webコンテナ・・・Javaプログラムの実行環境
    種類    container（コンテナ）入れ物、容器
    ・サーブレットの実行環境→サーブレットコンテナ
    ・JSPの実行環境        →JSPコンテナ
    ・上記2つのこと　       →ＷＥＢコンテナ
上記の図参照
<web-app>
contextPath:WebアプリケーションのURLのこと
例
http://localhost:8080/webapps
ここではwebapps

マッピングとは、Webコンテナがサーブレットを選んでクライアントの https://eng-entrance.com/java-servlet-mapping#i
リクエストを渡すためのものである。

Springboot





/*---　トラブル関連　---*/
Intelljideaで　Jの赤いマークが出たとき
・ソースルート外と示されているので、
    ファイル→プロジェクト構造→ソース→で追加？する。

/*---　外部ライブラリとAPIの各種実行方法についての関連知識　---*/
.lib (Library)

存在意義: ライブラリファイルであり、コンパイル時に他のプログラムとリンクするために使用されます。
開き方: .libファイルは通常、特定のプログラミング言語や開発環境によって使用されます。開発者はコンパイラやリンカなどの開発ツールを使用して、プログラムにリンクするために.libファイルを参照します。
.jar (Java Archive)

存在意義: Javaプログラムや関連するリソースをアーカイブするために使用されます。Javaアプリケーションやライブラリの配布や実行に使用されます。
開き方: .jarファイルはJavaの実行環境（Java Runtime Environment）によって実行されます。一般的には、java -jarコマンドを使用して実行することができます。また、一部の圧縮ツールやアーカイバツールを使用して、.jarファイルを展開して中身を確認することもできます。
.cfg (Configuration)

存在意義: 設定ファイルとして使用され、プログラムの動作や動作環境をカスタマイズするために利用されます。
開き方: .cfgファイルはテキストエディタや設定ファイルエディタなどのテキスト編集ツールを使用して開くことができます。内容は通常、プロパティやキーバリューペアなどの形式で記述されます。
.ja (Japanese Text)

存在意義: 日本語のテキストファイルであり、日本語の文章やコンテンツが含まれています。
開き方: .jaファイルはテキストエディタやワードプロセッサなどのテキスト編集ツールを使用して開くことができます。内容は日本語の文章やテキストで構成されています。
.sym (Symbol)

存在意義: プログラムのシンボル情報を含むファイルです。シンボル情報はデバッグやプロファイリングなどの目的で使用されます。
開き方: .symファイルは開発者向けのデバッグツール
/---*Intellj　Idea　ツール　について*---/
ショートカット
psvm public sta........ 




package ch08;
import java.io.*;

import javax.servlet.*;

import javax.servlet.http.*;

public class PostReceiptServlet extends HttpServlet {
  //doPost()メソッド
  public void doPost(HttpServletRequest request, HttpServletResponse response)
  throws ServletException, IOException {

      //パラメータの取得
      String name = request.getParameter("onamae");

      //コンテンツタイプの設定
      response.setContentType("text/html; charset=UTF-8");

      //画面出力
      PrintWriter out = response.getWriter();
      out.println("お名前は" + name + "さんですね。");
  }

 }

